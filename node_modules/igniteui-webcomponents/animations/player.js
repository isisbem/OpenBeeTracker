export class AnimationPlayer {
    constructor(target) {
        this.target = target;
    }
    prefersReducedMotion() {
        const query = window.matchMedia('(prefers-reduced-motion: reduce)');
        return query.matches;
    }
    parseKeyframes(keyframes) {
        return keyframes.map((keyframe) => ({
            ...keyframe,
            height: keyframe.height === 'auto'
                ? `${this.target.scrollHeight}px`
                : keyframe.height,
        }));
    }
    async play(animation) {
        const { steps, options } = animation;
        return new Promise((resolve) => {
            if ((options === null || options === void 0 ? void 0 : options.duration) === Infinity) {
                throw new Error('Promise-based animations must be finite.');
            }
            const parsedKeyframes = this.parseKeyframes(steps);
            const animation = this.target.animate(parsedKeyframes, {
                ...options,
                duration: this.prefersReducedMotion() ? 0 : options.duration,
            });
            animation.addEventListener('cancel', resolve, { once: true });
            animation.addEventListener('finish', resolve, { once: true });
        });
    }
    stopAll() {
        return Promise.all(this.target.getAnimations().map((animation) => {
            return new Promise((resolve) => {
                const handleAnimationEvent = () => requestAnimationFrame(resolve);
                animation.addEventListener('cancel', handleAnimationEvent, {
                    once: true,
                });
                animation.addEventListener('finish', handleAnimationEvent, {
                    once: true,
                });
                animation.cancel();
            });
        }));
    }
}
//# sourceMappingURL=player.js.map