var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, LitElement } from 'lit';
import { property, query, queryAssignedElements, state, } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { styleMap } from 'lit/directives/style-map.js';
import { themes } from '../../theming/theming-decorator.js';
import { blazorTypeOverride } from '../common/decorators/blazorTypeOverride.js';
import { watch } from '../common/decorators/watch.js';
import { styles } from './themes/light/slider.base.css.js';
import { styles as bootstrap } from './themes/light/slider.bootstrap.css.js';
import { styles as fluent } from './themes/light/slider.fluent.css.js';
import { styles as indigo } from './themes/light/slider.indigo.css.js';
import { styles as material } from './themes/light/slider.material.css.js';
import { defineComponents } from '../common/definitions/defineComponents.js';
import IgcSliderLabelComponent from './slider-label.js';
import { blazorDeepImport } from '../common/decorators/blazorDeepImport.js';
import { isLTR } from '../common/util.js';
defineComponents(IgcSliderLabelComponent);
let IgcSliderBaseComponent = class IgcSliderBaseComponent extends LitElement {
    set min(value) {
        if (value < this.max) {
            const oldVal = this._min;
            this._min = this.labels ? 0 : value;
            this.requestUpdate('min', oldVal);
            if (typeof this.lowerBound === 'number' && this.lowerBound < value) {
                this.lowerBound = value;
            }
        }
    }
    get min() {
        return this._min;
    }
    set max(value) {
        if (value > this.min) {
            const oldVal = this._max;
            this._max = this.labels ? this.labels.length - 1 : value;
            this.requestUpdate('max', oldVal);
            if (typeof this.upperBound === 'number' && this.upperBound > value) {
                this.upperBound = value;
            }
        }
    }
    get max() {
        return this._max;
    }
    set lowerBound(value) {
        const oldVal = this._lowerBound;
        if (typeof value === 'number') {
            this._lowerBound = this.valueInRange(value, this.min, this.actualMax);
        }
        else {
            this._lowerBound = value;
        }
        this.requestUpdate('lowerBound', oldVal);
    }
    get lowerBound() {
        return this._lowerBound;
    }
    set upperBound(value) {
        const oldVal = this._upperBound;
        if (typeof value === 'number') {
            this._upperBound = this.valueInRange(value, this.actualMin, this.max);
        }
        else {
            this._upperBound = value;
        }
        this.requestUpdate('upperBound', oldVal);
    }
    get upperBound() {
        return this._upperBound;
    }
    set step(value) {
        const oldVal = this._step;
        this._step = this.labels ? 1 : value;
        this.requestUpdate('step', oldVal);
    }
    get step() {
        return this._step;
    }
    constraintsChange() {
        this.normalizeValue();
    }
    labelsChange() {
        if (this.labels) {
            this.min = 0;
            this.max = this.labels.length - 1;
            this.step = 1;
        }
    }
    constructor() {
        super();
        this._min = 0;
        this._max = 100;
        this._step = 1;
        this.pointerCaptured = false;
        this.thumbLabelsVisible = false;
        this.disabled = false;
        this.discreteTrack = false;
        this.hideTooltip = false;
        this.primaryTicks = 0;
        this.secondaryTicks = 0;
        this.tickOrientation = 'end';
        this.hidePrimaryLabels = false;
        this.hideSecondaryLabels = false;
        this.locale = 'en';
        this.tickLabelRotation = 0;
        this.pointerDown = (event) => {
            var _a;
            const thumb = this.closestHandle(event);
            thumb.focus();
            this.startValue = this.activeValue;
            this.updateSlider(event.clientX);
            this.setPointerCapture(event.pointerId);
            this.pointerCaptured = true;
            this.showThumbLabels();
            event.preventDefault();
            (_a = this.activeThumb) === null || _a === void 0 ? void 0 : _a.part.remove('focused');
        };
        this.pointerMove = (event) => {
            if (this.pointerCaptured) {
                this.updateSlider(event.clientX);
            }
        };
        this.lostPointerCapture = () => {
            this.pointerCaptured = false;
            this.hideThumbLabels();
            if (this.startValue !== this.activeValue) {
                this.emitChangeEvent();
            }
            this.startValue = undefined;
        };
        this.handleKeydown = (event) => {
            if (this.disabled) {
                return;
            }
            const { key } = event;
            let increment = 0;
            const value = this.activeValue;
            const step = this.step ? this.step : 1;
            const ltr = isLTR(this);
            switch (key) {
                case 'ArrowLeft':
                    increment += ltr ? -step : step;
                    break;
                case 'ArrowRight':
                    increment += ltr ? step : -step;
                    break;
                case 'ArrowUp':
                    increment = step;
                    break;
                case 'ArrowDown':
                    increment = -step;
                    break;
                case 'Home':
                    increment = this.actualMin - value;
                    break;
                case 'End':
                    increment = this.actualMax - value;
                    break;
                case 'PageUp':
                    increment = Math.max((this.actualMax - this.actualMin) / 10, step);
                    break;
                case 'PageDown':
                    increment = -Math.max((this.actualMax - this.actualMin) / 10, step);
                    break;
                default:
                    return;
            }
            if (increment) {
                const updated = this.updateValue(increment);
                this.showThumbLabels();
                this.hideThumbLabels();
                if (updated) {
                    this.emitChangeEvent();
                }
            }
        };
        this.handleThumbPointerEnter = () => {
            this.showThumbLabels();
        };
        this.handleThumbPointerLeave = () => {
            this.hideThumbLabels();
        };
        this.addEventListener('pointerdown', this.pointerDown);
        this.addEventListener('pointermove', this.pointerMove);
        this.addEventListener('lostpointercapture', this.lostPointerCapture);
        this.addEventListener('keydown', this.handleKeydown);
    }
    connectedCallback() {
        super.connectedCallback();
        this.normalizeValue();
        this.addEventListener('keyup', this.handleKeyUp);
    }
    disconnectedCallback() {
        this.removeEventListener('keyup', this.handleKeyUp);
        super.disconnectedCallback();
    }
    handleKeyUp() {
        var _a;
        (_a = this.activeThumb) === null || _a === void 0 ? void 0 : _a.part.add('focused');
    }
    handleSlotChange() {
        this.labels =
            this.labelElements && this.labelElements.length
                ? this.labelElements.map((e) => e.textContent)
                : undefined;
    }
    get activeValue() {
        return 0;
    }
    normalizeValue() { }
    getTrackStyle() {
        return {};
    }
    updateValue(_increment) {
        return false;
    }
    renderThumbs() {
        return html ``;
    }
    emitInputEvent() { }
    emitChangeEvent() { }
    get actualMin() {
        return typeof this.lowerBound === 'number'
            ? this.lowerBound
            : this.min;
    }
    get actualMax() {
        return typeof this.upperBound === 'number'
            ? this.upperBound
            : this.max;
    }
    validateValue(value) {
        value = this.valueInRange(value, this.actualMin, this.actualMax);
        value = this.normalizeByStep(value);
        return value;
    }
    formatValue(value) {
        return this.valueFormat
            ? this.valueFormat.replace('{0}', value.toLocaleString(this.locale, this.valueFormatOptions))
            : value.toLocaleString(this.locale, this.valueFormatOptions);
    }
    normalizeByStep(value) {
        return this.step ? value - ((value - this.actualMin) % this.step) : value;
    }
    closestHandle(_event) {
        return this.thumb;
    }
    totalTickCount() {
        const primaryTicks = this.labels
            ? this.primaryTicks > 0
                ? this.labels.length
                : 0
            : this.primaryTicks === 1
                ? 2
                : this.primaryTicks;
        return primaryTicks > 0
            ? (primaryTicks - 1) * this.secondaryTicks + primaryTicks
            : this.secondaryTicks > 0
                ? this.secondaryTicks
                : 0;
    }
    tickValue(idx) {
        const tickCount = this.totalTickCount();
        const labelStep = tickCount > 1
            ? (this.max - this.min) / (tickCount - 1)
            : this.max - this.min;
        const labelVal = labelStep * idx;
        return this.min + labelVal;
    }
    isPrimary(idx) {
        return this.primaryTicks <= 0
            ? false
            : idx % (this.secondaryTicks + 1) === 0;
    }
    showThumbLabels() {
        if (this.disabled || this.hideTooltip) {
            return;
        }
        if (this.thumbHoverTimer) {
            clearTimeout(this.thumbHoverTimer);
            this.thumbHoverTimer = null;
        }
        this.thumbLabelsVisible = true;
    }
    hideThumbLabels() {
        if (this.pointerCaptured || !this.thumbLabelsVisible) {
            return;
        }
        this.thumbHoverTimer = setTimeout(() => {
            this.thumbLabelsVisible = false;
        }, 750);
    }
    valueInRange(value, min = 0, max = 100) {
        return Math.max(Math.min(value, max), min);
    }
    valueToFraction(value) {
        return (value - this.min) / (this.max - this.min);
    }
    calculateTrackUpdate(mouseX) {
        if (!this.activeThumb) {
            return 0;
        }
        const thumbBoundaries = this.activeThumb.getBoundingClientRect();
        const thumbCenter = (thumbBoundaries.right - thumbBoundaries.left) / 2;
        const thumbPositionX = thumbBoundaries.left + thumbCenter;
        const scale = this.getBoundingClientRect().width / (this.max - this.min);
        const change = isLTR(this)
            ? mouseX - thumbPositionX
            : thumbPositionX - mouseX;
        if (this.step) {
            const stepDistance = scale * this.step;
            const stepDistanceCenter = stepDistance / 2;
            const scaleXPositive = Math.abs(change);
            if (scaleXPositive < stepDistanceCenter) {
                return 0;
            }
            return Math.round(change / stepDistance) * this.step;
        }
        else {
            return change / scale;
        }
    }
    updateSlider(mouseX) {
        if (this.disabled) {
            return;
        }
        const increment = this.calculateTrackUpdate(mouseX);
        if (this.activeThumb && increment !== 0) {
            this.updateValue(increment);
        }
    }
    renderTicks() {
        const groups = [];
        for (let i = 0, totalCount = this.totalTickCount(); i < totalCount; i++) {
            const isPrimary = this.isPrimary(i);
            groups.push(html `
        <div part="tick-group">
          <div part="tick" data-primary=${isPrimary}>
            ${(isPrimary ? this.hidePrimaryLabels : this.hideSecondaryLabels)
                ? html ``
                : html `
                  <div part="tick-label">
                    <span part="tick-label-inner">
                      ${this.labels
                    ? isPrimary
                        ? this.labels[Math.round(i / (this.secondaryTicks + 1))]
                        : ''
                    : this.formatValue(this.tickValue(i))}
                    </span>
                  </div>
                `}
          </div>
        </div>
      `);
        }
        return groups;
    }
    renderThumb(value, ariaLabel, thumbId) {
        const percent = `${this.valueToFraction(value) * 100}%`;
        return html `
      <div
        part="thumb"
        id=${ifDefined(thumbId)}
        tabindex=${this.disabled ? -1 : 0}
        style=${styleMap({ insetInlineStart: percent })}
        role="slider"
        aria-valuemin=${this.actualMin}
        aria-valuemax=${this.actualMax}
        aria-valuenow=${value}
        aria-valuetext=${ifDefined(this.labels
            ? this.labels[value]
            : this.valueFormat || this.valueFormatOptions
                ? this.formatValue(value)
                : undefined)}
        aria-label=${ifDefined(ariaLabel)}
        aria-disabled=${this.disabled ? 'true' : 'false'}
        @pointerenter=${this.handleThumbPointerEnter}
        @pointerleave=${this.handleThumbPointerLeave}
        @focus=${(ev) => (this.activeThumb = ev.target)}
        @blur=${() => {
            var _a;
            return ((_a = this.activeThumb) === null || _a === void 0 ? void 0 : _a.part.remove('focused'),
                (this.activeThumb = undefined));
        }}
      ></div>
      ${this.hideTooltip
            ? html ``
            : html `
            <div
              part="thumb-label"
              style=${styleMap({
                opacity: this.thumbLabelsVisible ? '1' : '0',
                insetInlineStart: percent,
            })}
            >
              <div part="thumb-label-inner">
                ${this.labels ? this.labels[value] : this.formatValue(value)}
              </div>
            </div>
          `}
    `;
    }
    renderSteps() {
        if (!this.discreteTrack || !this.step) {
            return html ``;
        }
        const trackRange = this.max - this.min;
        const interval = ((100 / (trackRange / this.step)) * 10) / 10;
        return html `
      <div part="steps">
        <svg width="100%" height="100%" style="display: flex">
          <line
            x1="0"
            y1="1"
            x2="100%"
            y2="1"
            stroke="currentColor"
            stroke-dasharray="0, calc(${interval * Math.sqrt(2)}%)"
            stroke-linecap="round"
            stroke-width="2px"
          ></line>
        </svg>
      </div>
    `;
    }
    render() {
        return html `
      <div part="base">
        ${this.tickOrientation === 'mirror' || this.tickOrientation === 'start'
            ? html `<div part="ticks">${this.renderTicks()}</div>`
            : html ``}
        <div part="track">
          <div part="inactive"></div>
          <div part="fill" style=${styleMap(this.getTrackStyle())}></div>
          ${this.renderSteps()}
        </div>
        ${this.tickOrientation !== 'start'
            ? html `<div part="ticks">${this.renderTicks()}</div>`
            : html ``}
        <div part="thumbs">${this.renderThumbs()}</div>
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
    }
};
IgcSliderBaseComponent.styles = styles;
__decorate([
    query(`[part~='thumb']`)
], IgcSliderBaseComponent.prototype, "thumb", void 0);
__decorate([
    queryAssignedElements({ selector: 'igc-slider-label' })
], IgcSliderBaseComponent.prototype, "labelElements", void 0);
__decorate([
    state()
], IgcSliderBaseComponent.prototype, "thumbLabelsVisible", void 0);
__decorate([
    state()
], IgcSliderBaseComponent.prototype, "labels", void 0);
__decorate([
    property({ type: Number })
], IgcSliderBaseComponent.prototype, "min", null);
__decorate([
    property({ type: Number })
], IgcSliderBaseComponent.prototype, "max", null);
__decorate([
    property({ type: Number, attribute: 'lower-bound' })
], IgcSliderBaseComponent.prototype, "lowerBound", null);
__decorate([
    property({ type: Number, attribute: 'upper-bound' })
], IgcSliderBaseComponent.prototype, "upperBound", null);
__decorate([
    property({ type: Boolean, reflect: true })
], IgcSliderBaseComponent.prototype, "disabled", void 0);
__decorate([
    property({ type: Boolean, attribute: 'discrete-track' })
], IgcSliderBaseComponent.prototype, "discreteTrack", void 0);
__decorate([
    property({ type: Boolean, attribute: 'hide-tooltip' })
], IgcSliderBaseComponent.prototype, "hideTooltip", void 0);
__decorate([
    property({ type: Number })
], IgcSliderBaseComponent.prototype, "step", null);
__decorate([
    property({ type: Number, attribute: 'primary-ticks' })
], IgcSliderBaseComponent.prototype, "primaryTicks", void 0);
__decorate([
    property({ type: Number, attribute: 'secondary-ticks' })
], IgcSliderBaseComponent.prototype, "secondaryTicks", void 0);
__decorate([
    property({ attribute: 'tick-orientation' })
], IgcSliderBaseComponent.prototype, "tickOrientation", void 0);
__decorate([
    property({ type: Boolean, attribute: 'hide-primary-labels' })
], IgcSliderBaseComponent.prototype, "hidePrimaryLabels", void 0);
__decorate([
    property({ type: Boolean, attribute: 'hide-secondary-labels' })
], IgcSliderBaseComponent.prototype, "hideSecondaryLabels", void 0);
__decorate([
    property()
], IgcSliderBaseComponent.prototype, "locale", void 0);
__decorate([
    property({ attribute: 'value-format' })
], IgcSliderBaseComponent.prototype, "valueFormat", void 0);
__decorate([
    property({ attribute: false })
], IgcSliderBaseComponent.prototype, "valueFormatOptions", void 0);
__decorate([
    property({ type: Number, reflect: true, attribute: 'tick-label-rotation' }),
    blazorTypeOverride('TickLabelRotation', true)
], IgcSliderBaseComponent.prototype, "tickLabelRotation", void 0);
__decorate([
    watch('min', { waitUntilFirstUpdate: true }),
    watch('max', { waitUntilFirstUpdate: true }),
    watch('lowerBound', { waitUntilFirstUpdate: true }),
    watch('upperBound', { waitUntilFirstUpdate: true }),
    watch('step', { waitUntilFirstUpdate: true })
], IgcSliderBaseComponent.prototype, "constraintsChange", null);
__decorate([
    watch('labels')
], IgcSliderBaseComponent.prototype, "labelsChange", null);
IgcSliderBaseComponent = __decorate([
    themes({ material, bootstrap, fluent, indigo }),
    blazorDeepImport
], IgcSliderBaseComponent);
export { IgcSliderBaseComponent };
//# sourceMappingURL=slider-base.js.map