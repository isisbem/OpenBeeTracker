var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html } from 'lit';
import { property, query } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { styleMap } from 'lit/directives/style-map.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import { IgcSliderBaseComponent } from './slider-base.js';
export default class IgcRangeSliderComponent extends EventEmitterMixin(IgcSliderBaseComponent) {
    constructor() {
        super(...arguments);
        this._lower = 0;
        this._upper = 0;
    }
    set lower(val) {
        const oldVal = this._lower;
        this._lower = this.validateValue(val);
        this.requestUpdate('lower', oldVal);
    }
    get lower() {
        return this._lower;
    }
    set upper(val) {
        const oldVal = this._upper;
        this._upper = this.validateValue(val);
        this.requestUpdate('upper', oldVal);
    }
    get upper() {
        return this._upper;
    }
    get activeValue() {
        return this.activeThumb === this.thumbFrom ? this.lower : this.upper;
    }
    normalizeValue() {
        this._lower = this.validateValue(this._lower);
        this._upper = this.validateValue(this._upper);
    }
    getTrackStyle() {
        const toPosition = this.valueToFraction(this.upper);
        const fromPosition = this.valueToFraction(this.lower);
        const positionGap = toPosition - fromPosition;
        const filledTrackStyle = {
            width: `${positionGap * 100}%`,
            insetInlineStart: `${fromPosition * 100}%`,
        };
        return filledTrackStyle;
    }
    closestTo(goal, positions) {
        return positions.reduce((previous, current) => Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous);
    }
    closestHandle(event) {
        const fromOffset = this.thumbFrom.offsetLeft + this.thumbFrom.offsetWidth / 2;
        const toOffset = this.thumbTo.offsetLeft + this.thumbTo.offsetWidth / 2;
        const xPointer = event.clientX - this.getBoundingClientRect().left;
        const match = this.closestTo(xPointer, [fromOffset, toOffset]);
        if (fromOffset === toOffset && toOffset < xPointer) {
            return this.thumbTo;
        }
        else if (fromOffset === toOffset && toOffset > xPointer) {
            return this.thumbFrom;
        }
        else if (match === fromOffset) {
            return this.thumbFrom;
        }
        else {
            return this.thumbTo;
        }
    }
    updateValue(increment) {
        const oldValue = this.activeValue;
        let lower = this.lower;
        let upper = this.upper;
        if (this.activeThumb === this.thumbFrom) {
            lower += increment;
        }
        else {
            upper += increment;
        }
        if (lower >= upper) {
            this.swapValues(lower, upper);
            this.toggleActiveThumb();
        }
        else {
            if (this.activeThumb === this.thumbFrom) {
                this.lower = lower;
            }
            else {
                this.upper = upper;
            }
        }
        if (oldValue === this.activeValue) {
            return false;
        }
        this.emitInputEvent();
        return true;
    }
    emitInputEvent() {
        this.emitEvent('igcInput', {
            detail: { lower: this.lower, upper: this.upper },
        });
    }
    emitChangeEvent() {
        this.emitEvent('igcChange', {
            detail: { lower: this.lower, upper: this.upper },
        });
    }
    swapValues(lower, upper) {
        this.lower = upper;
        this.upper = lower;
    }
    toggleActiveThumb() {
        const thumb = this.activeThumb === this.thumbFrom ? this.thumbTo : this.thumbFrom;
        thumb.focus();
    }
    handleFocus(ev) {
        var _a, _b;
        this.activeThumb = ev.target;
        const thumbId = (_a = this.activeThumb) === null || _a === void 0 ? void 0 : _a.id;
        const thumbs = (_b = this.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelectorAll('div[part="thumb"]');
        thumbs === null || thumbs === void 0 ? void 0 : thumbs.forEach((t) => {
            var _a;
            if (t.id !== thumbId) {
                const activeThumbVal = parseFloat(this.activeThumb.ariaValueNow);
                const thumbVal = parseFloat(t.ariaValueNow);
                const rangeFrom = Math.min(activeThumbVal, thumbVal);
                const rangeTo = Math.max(activeThumbVal, thumbVal);
                (_a = this.activeThumb) === null || _a === void 0 ? void 0 : _a.setAttribute('aria-valuetext', `${this.formatValue(rangeFrom)} - ${this.formatValue(rangeTo)}`);
            }
        });
    }
    renderThumb(value, ariaLabel, thumbId) {
        const percent = `${this.valueToFraction(value) * 100}%`;
        const ariaValueText = thumbId === 'thumbFrom' ? `min ${this.lower}` : `max ${this.upper}`;
        const textValue = this.labels
            ? this.labels[value]
            : this.valueFormat || this.valueFormatOptions
                ? this.formatValue(value)
                : ariaValueText;
        return html `
      <div
        part="thumb"
        id=${ifDefined(thumbId)}
        tabindex=${this.disabled ? -1 : 0}
        style=${styleMap({ insetInlineStart: percent })}
        role="slider"
        aria-valuemin=${this.actualMin}
        aria-valuemax=${this.actualMax}
        aria-valuenow=${value}
        aria-valuetext=${ifDefined(textValue)}
        aria-label=${ifDefined(ariaLabel)}
        aria-disabled=${this.disabled ? 'true' : 'false'}
        @pointerenter=${this.handleThumbPointerEnter}
        @pointerleave=${this.handleThumbPointerLeave}
        @focus=${(ev) => this.handleFocus(ev)}
        @blur=${() => {
            var _a;
            return ((_a = this.activeThumb) === null || _a === void 0 ? void 0 : _a.part.remove('focused'),
                (this.activeThumb = undefined));
        }}
      ></div>
      ${this.hideTooltip
            ? html ``
            : html `
            <div
              part="thumb-label"
              style=${styleMap({
                opacity: this.thumbLabelsVisible ? '1' : '0',
                insetInlineStart: percent,
            })}
            >
              <div part="thumb-label-inner">
                ${this.labels ? this.labels[value] : this.formatValue(value)}
              </div>
            </div>
          `}
    `;
    }
    renderThumbs() {
        return html `${this.renderThumb(this.lower, this.ariaLabelLower, 'thumbFrom')}
    ${this.renderThumb(this.upper, this.ariaLabelUpper, 'thumbTo')}`;
    }
}
IgcRangeSliderComponent.tagName = 'igc-range-slider';
__decorate([
    query(`#thumbFrom`)
], IgcRangeSliderComponent.prototype, "thumbFrom", void 0);
__decorate([
    query(`#thumbTo`)
], IgcRangeSliderComponent.prototype, "thumbTo", void 0);
__decorate([
    property({ type: Number })
], IgcRangeSliderComponent.prototype, "lower", null);
__decorate([
    property({ type: Number })
], IgcRangeSliderComponent.prototype, "upper", null);
__decorate([
    property({ attribute: 'aria-label-lower' })
], IgcRangeSliderComponent.prototype, "ariaLabelLower", void 0);
__decorate([
    property({ attribute: 'aria-label-upper' })
], IgcRangeSliderComponent.prototype, "ariaLabelUpper", void 0);
//# sourceMappingURL=range-slider.js.map