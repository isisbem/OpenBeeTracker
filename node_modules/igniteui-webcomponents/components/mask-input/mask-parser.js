const FLAGS = new Set('aACL09#&?');
const REGEX = new Map([
    ['C', /(?!^$)/u],
    ['&', /[^\p{Separator}]/u],
    ['a', /[\p{Letter}\d\p{Separator}]/u],
    ['A', /[\p{Letter}\d]/u],
    ['?', /[\p{Letter}\p{Separator}]/u],
    ['L', /\p{Letter}/u],
    ['0', /\d/],
    ['9', /[\d\p{Separator}]/u],
    ['#', /[\d\-+]/],
]);
const REQUIRED = new Set('0#LA&');
const replaceIMENumbers = (string) => {
    return string.replace(/[０１２３４５６７８９]/g, (num) => ({
        '１': '1',
        '２': '2',
        '３': '3',
        '４': '4',
        '５': '5',
        '６': '6',
        '７': '7',
        '８': '8',
        '９': '9',
        '０': '0',
    }[num]));
};
export class MaskParser {
    constructor(options = { format: 'CCCCCCCCCC', promptCharacter: '_' }) {
        this.literals = new Map();
        this.options = options;
    }
    get literalPositions() {
        this.getMaskLiterals();
        return Array.from(this.literals.keys());
    }
    get escapedMask() {
        this.getMaskLiterals();
        return this._escapedMask;
    }
    get mask() {
        return this.options.format;
    }
    set mask(value) {
        this.options.format = value || this.options.format;
        this.getMaskLiterals();
    }
    get prompt() {
        return this.options.promptCharacter;
    }
    set prompt(value) {
        this.options.promptCharacter = value
            ? value.substring(0, 1)
            : this.options.promptCharacter;
    }
    getMaskLiterals() {
        this.literals.clear();
        this._escapedMask = this.mask;
        for (let i = 0, j = 0; i < this.mask.length; i++, j++) {
            const [current, next] = [this.mask.charAt(i), this.mask.charAt(i + 1)];
            if (current === '\\' && FLAGS.has(next)) {
                this._escapedMask = this.replaceCharAt(this._escapedMask, j, '');
                this.literals.set(j, next);
                i++;
            }
            else {
                if (!FLAGS.has(current)) {
                    this.literals.set(j, current);
                }
            }
        }
    }
    isPromptChar(char) {
        return char === this.prompt;
    }
    replaceCharAt(string, pos, char) {
        return `${string.substring(0, pos)}${char}${string.substring(pos + 1)}`;
    }
    validate(char, maskedChar) {
        const regex = REGEX.get(maskedChar);
        return regex ? regex.test(char) : false;
    }
    getNonLiteralPositions(mask = '') {
        const positions = this.literalPositions;
        return Array.from(mask)
            .map((_, pos) => (!positions.includes(pos) ? pos : -1))
            .filter((pos) => pos > -1);
    }
    getRequiredNonLiteralPositions(mask) {
        const positions = this.literalPositions;
        return Array.from(mask)
            .map((char, pos) => REQUIRED.has(char) && !positions.includes(pos) ? pos : -1)
            .filter((pos) => pos > -1);
    }
    getPreviousNonLiteralPosition(start) {
        const positions = this.literalPositions;
        for (let i = start; i > 0; i--) {
            if (!positions.includes(i))
                return i;
        }
        return start;
    }
    getNextNonLiteralPosition(start) {
        const positions = this.literalPositions;
        for (let i = start; i < this._escapedMask.length; i++) {
            if (!positions.includes(i))
                return i;
        }
        return start;
    }
    replace(masked = '', value, start, end) {
        const chars = Array.from(replaceIMENumbers(value));
        const positions = this.literalPositions;
        end = Math.min(end, masked.length);
        let cursor = start;
        for (let i = start; i < end || (chars.length && i < masked.length); i++) {
            if (positions.includes(i)) {
                if (chars[0] === masked[i]) {
                    cursor = i + 1;
                    chars.shift();
                }
                continue;
            }
            if (chars[0] &&
                !this.validate(chars[0], this._escapedMask[i]) &&
                !this.isPromptChar(chars[0])) {
                break;
            }
            let char = this.prompt;
            if (chars.length) {
                cursor = i + 1;
                char = chars.shift();
            }
            masked = this.replaceCharAt(masked, i, char);
        }
        return { value: masked, end: cursor };
    }
    parse(masked = '') {
        return Array.from(masked).reduce((prev, char, pos) => {
            return `${prev}${!this.literalPositions.includes(pos) && !this.isPromptChar(char)
                ? char
                : ''}`;
        }, '');
    }
    isValidString(input = '') {
        const required = this.getRequiredNonLiteralPositions(this._escapedMask);
        if (required.length > this.parse(input).length) {
            return false;
        }
        return required.every((pos) => {
            const char = input.charAt(pos);
            return (char !== undefined &&
                this.validate(char, this._escapedMask.charAt(pos)) &&
                !this.isPromptChar(char));
        });
    }
    apply(input = '') {
        const nonLiteralPositions = this.getNonLiteralPositions(this._escapedMask);
        let output = new Array(this._escapedMask.length).fill(this.prompt).join('');
        this.literals.forEach((char, pos) => {
            output = this.replaceCharAt(output, pos, char);
        });
        if (!input) {
            return output;
        }
        const values = nonLiteralPositions.map((pos, index) => {
            const char = input.charAt(index);
            return !this.validate(char, this._escapedMask.charAt(pos)) &&
                !this.isPromptChar(char)
                ? this.prompt
                : char;
        });
        if (values.length > nonLiteralPositions.length) {
            values.splice(nonLiteralPositions.length);
        }
        let pos = 0;
        for (const each of values) {
            output = this.replaceCharAt(output, nonLiteralPositions[pos++], each);
        }
        return output;
    }
}
//# sourceMappingURL=mask-parser.js.map