var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, LitElement, nothing } from 'lit';
import { property, query, queryAssignedNodes, state } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { styleMap } from 'lit/directives/style-map.js';
import { guard } from 'lit/directives/guard.js';
import { themes } from '../../theming/theming-decorator.js';
import { watch } from '../common/decorators/watch.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import { SizableMixin } from '../common/mixins/sizable.js';
import { clamp, isLTR } from '../common/util.js';
import { styles } from './rating.base.css.js';
import { styles as bootstrap } from './rating.bootstrap.css.js';
import { styles as fluent } from './rating.fluent.css.js';
import { styles as indigo } from './rating.indigo.css.js';
import { defineComponents } from '../common/definitions/defineComponents.js';
import IgcRatingSymbolComponent from './rating-symbol.js';
import IgcIconComponent from '../icon/icon.js';
defineComponents(IgcRatingSymbolComponent, IgcIconComponent);
let IgcRatingComponent = class IgcRatingComponent extends SizableMixin(EventEmitterMixin(LitElement)) {
    get isInteractive() {
        return !(this.readonly || this.disabled);
    }
    get hasProjectedSymbols() {
        return this.ratingSymbols.length > 0;
    }
    get valueText() {
        const value = this.round(this.value);
        return this.valueFormat
            ? this.valueFormat
                .replace(/\{0\}/gm, `${value}`)
                .replace(/\{1\}/gm, `${this.max}`)
            : `${value} of ${this.max}`;
    }
    handleMaxChange() {
        this.hasProjectedSymbols
            ? (this.max = this.ratingSymbols.length)
            : (this.max = Math.max(0, this.max));
        if (this.max < this.value) {
            this.value = this.max;
        }
    }
    handleValueChange() {
        this.value = clamp(this.value, 0, this.max);
    }
    handlePrecisionChange() {
        this.step = !this.single ? clamp(this.step, 0.001, 1) : 1;
    }
    handleSelectionChange() {
        if (this.single) {
            this.step = 1;
            this.value = Math.ceil(this.value);
        }
    }
    constructor() {
        super();
        this.ratingSymbols = [];
        this.hoverValue = -1;
        this.hoverState = false;
        this.max = 5;
        this.step = 1;
        this.value = 0;
        this.disabled = false;
        this.hoverPreview = false;
        this.readonly = false;
        this.single = false;
        this.addEventListener('keydown', this.handleKeyDown);
    }
    handleClick({ clientX }) {
        if (!this.isInteractive) {
            return;
        }
        const value = this.calcNewValue(clientX);
        this.value === value ? (this.value = 0) : (this.value = value);
        this.emitEvent('igcChange', { detail: this.value });
    }
    handleMouseMove({ clientX }) {
        if (!this.isInteractive) {
            return;
        }
        const value = this.calcNewValue(clientX);
        if (this.hoverValue !== value) {
            this.hoverValue = value;
            this.emitEvent('igcHover', { detail: this.hoverValue });
        }
    }
    handleMouseEnter() {
        if (this.isInteractive) {
            this.hoverState = true;
        }
    }
    handleMouseLeave() {
        if (this.isInteractive) {
            this.hoverState = false;
        }
    }
    handleKeyDown({ key }) {
        if (!this.isInteractive) {
            return;
        }
        let result = this.value;
        const ltr = isLTR(this);
        switch (key) {
            case 'ArrowUp':
            case 'ArrowRight':
                result += ltr ? this.step : -this.step;
                break;
            case 'ArrowDown':
            case 'ArrowLeft':
                result -= ltr ? this.step : -this.step;
                break;
            case 'Home':
                result = this.step;
                break;
            case 'End':
                result = this.max;
                break;
            default:
                return;
        }
        this.value = clamp(result, 0, this.max);
        if (result === this.value) {
            this.emitEvent('igcChange', { detail: this.value });
        }
    }
    handleSlotChange(event) {
        const slot = event.target;
        this.ratingSymbols = slot
            .assignedElements()
            .filter((el) => el instanceof IgcRatingSymbolComponent);
        if (this.hasProjectedSymbols) {
            this.max = this.ratingSymbols.length;
        }
        this.requestUpdate();
    }
    calcNewValue(x) {
        const { width, left, right } = this.container.getBoundingClientRect();
        const percent = isLTR(this) ? (x - left) / width : (right - x) / width;
        const value = this.round(this.max * percent + this.step / 2);
        return clamp(value, this.step, this.max);
    }
    getPrecision(num) {
        const [_, decimal] = num.toString().split('.');
        return decimal ? decimal.length : 0;
    }
    round(value) {
        value = Math.round(value / this.step) * this.step;
        return Number(value.toFixed(this.getPrecision(this.step)));
    }
    clipSymbol(index, isLTR = true) {
        const value = this.hoverState ? this.hoverValue : this.value;
        const progress = index + 1 - value;
        const exclusive = progress === 0 || this.value === index + 1 ? 0 : 1;
        const selection = this.single ? exclusive : progress;
        const activate = (p) => clamp(p * 100, 0, 100);
        const forward = `inset(0 ${activate(isLTR ? selection : 1 - selection)}% 0 0)`;
        const backward = `inset(0 0 0 ${activate(isLTR ? 1 - selection : selection)}%)`;
        return {
            backward: isLTR ? backward : forward,
            forward: isLTR ? forward : backward,
        };
    }
    stepUp(n = 1) {
        this.value += this.round(n * this.step);
    }
    stepDown(n = 1) {
        this.value -= this.round(n * this.step);
    }
    *renderSymbols() {
        const ltr = isLTR(this);
        for (let i = 0; i < this.max; i++) {
            const { forward, backward } = this.clipSymbol(i, ltr);
            yield html `<igc-rating-symbol exportparts="symbol, full, empty">
        <igc-icon
          collection="internal"
          name="star"
          style=${styleMap({ clipPath: forward })}
        ></igc-icon>
        <igc-icon
          collection="internal"
          name="star_border"
          style=${styleMap({ clipPath: backward })}
          slot="empty"
        ></igc-icon>
      </igc-rating-symbol>`;
        }
    }
    clipProjected() {
        if (this.hasProjectedSymbols) {
            const ltr = isLTR(this);
            this.ratingSymbols.forEach((symbol, i) => {
                var _a, _b;
                const full = (_a = symbol.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('[part="symbol full"]');
                const empty = (_b = symbol.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector('[part="symbol empty"]');
                const { forward, backward } = this.clipSymbol(i, ltr);
                if (full) {
                    full.style.clipPath = forward;
                }
                if (empty) {
                    empty.style.clipPath = backward;
                }
            });
        }
    }
    render() {
        const props = [
            this.value,
            this.hoverValue,
            this.max,
            this.step,
            this.single,
            this.hoverState,
            this.ratingSymbols,
        ];
        return html `
      <label part="label" id="rating-label" ?hidden=${!this.label}
        >${this.label}</label
      >
      <div
        part="base"
        role="slider"
        tabindex=${ifDefined(this.disabled ? undefined : 0)}
        aria-labelledby="rating-label"
        aria-valuemin="0"
        aria-valuenow=${this.value}
        aria-valuemax=${this.max}
        aria-valuetext=${this.valueText}
      >
        <div
          aria-hidden="true"
          part="symbols"
          @click=${this.handleClick}
          @mouseenter=${this.hoverPreview ? this.handleMouseEnter : nothing}
          @mouseleave=${this.hoverPreview ? this.handleMouseLeave : nothing}
          @mousemove=${this.hoverPreview ? this.handleMouseMove : nothing}
        >
          <slot name="symbol" @slotchange=${this.handleSlotChange}>
            ${guard(props, () => {
            this.clipProjected();
            return this.renderSymbols();
        })}
          </slot>
        </div>
        <label part="value-label" ?hidden=${this.valueLabel.length === 0}>
          <slot name="value-label"></slot>
        </label>
      </div>
    `;
    }
};
IgcRatingComponent.tagName = 'igc-rating';
IgcRatingComponent.styles = [styles];
__decorate([
    query('[part="symbols"]', true)
], IgcRatingComponent.prototype, "container", void 0);
__decorate([
    queryAssignedNodes({ slot: 'value-label', flatten: true })
], IgcRatingComponent.prototype, "valueLabel", void 0);
__decorate([
    state()
], IgcRatingComponent.prototype, "hoverValue", void 0);
__decorate([
    state()
], IgcRatingComponent.prototype, "hoverState", void 0);
__decorate([
    property({ type: Number })
], IgcRatingComponent.prototype, "max", void 0);
__decorate([
    property({ type: Number })
], IgcRatingComponent.prototype, "step", void 0);
__decorate([
    property()
], IgcRatingComponent.prototype, "name", void 0);
__decorate([
    property()
], IgcRatingComponent.prototype, "label", void 0);
__decorate([
    property({ attribute: 'value-format' })
], IgcRatingComponent.prototype, "valueFormat", void 0);
__decorate([
    property({ type: Number })
], IgcRatingComponent.prototype, "value", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], IgcRatingComponent.prototype, "disabled", void 0);
__decorate([
    property({ type: Boolean, reflect: true, attribute: 'hover-preview' })
], IgcRatingComponent.prototype, "hoverPreview", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], IgcRatingComponent.prototype, "readonly", void 0);
__decorate([
    property({ type: Boolean })
], IgcRatingComponent.prototype, "single", void 0);
__decorate([
    watch('max')
], IgcRatingComponent.prototype, "handleMaxChange", null);
__decorate([
    watch('value')
], IgcRatingComponent.prototype, "handleValueChange", null);
__decorate([
    watch('step')
], IgcRatingComponent.prototype, "handlePrecisionChange", null);
__decorate([
    watch('single')
], IgcRatingComponent.prototype, "handleSelectionChange", null);
IgcRatingComponent = __decorate([
    themes({ fluent, bootstrap, indigo })
], IgcRatingComponent);
export default IgcRatingComponent;
//# sourceMappingURL=rating.js.map