var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html } from 'lit';
import { property } from 'lit/decorators.js';
import { live } from 'lit/directives/live.js';
import { DateParts, DatePart, DateTimeUtil, } from './date-util.js';
import { blazorTwoWayBind } from '../common/decorators/blazorTwoWayBind.js';
import { watch } from '../common/decorators/watch.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { IgcMaskInputBaseComponent, } from '../mask-input/mask-input-base.js';
import { partNameMap } from '../common/util.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
export default class IgcDateTimeInputComponent extends EventEmitterMixin(IgcMaskInputBaseComponent) {
    get inputFormat() {
        return this._inputFormat || this._defaultMask;
    }
    set inputFormat(val) {
        if (val) {
            this.setMask(val);
            this._inputFormat = val;
        }
    }
    get value() {
        return this._value;
    }
    set value(val) {
        this._value = val
            ? DateTimeUtil.isValidDate(val)
                ? val
                : DateTimeUtil.parseIsoDate(val)
            : null;
        this.updateMask();
        this.validate();
    }
    setDefaultMask() {
        if (!this._inputFormat) {
            this.updateDefaultMask();
            this.setMask(this._defaultMask);
        }
        if (this.value) {
            this.updateMask();
        }
    }
    setDisplayFormat() {
        if (this.displayFormat) {
            if (this.value) {
                this.maskedValue = DateTimeUtil.formatDate(this.value, this.locale, this.displayFormat, true);
            }
        }
    }
    promptChange() {
        if (!this.prompt) {
            this.prompt = this.parser.prompt;
        }
        else {
            this.parser.prompt = this.prompt;
        }
    }
    handleInvalidState() {
        this.updateComplete.then(() => (this.invalid = !this.input.checkValidity()));
    }
    validate() {
        if (!this.value) {
            return null;
        }
        let errors = {};
        if (this.minValue || this.maxValue) {
            errors = DateTimeUtil.validateMinMax(this.value, this.minValue, this.maxValue, this.hasTimeParts, this.hasDateParts);
            if (Object.keys(errors).length > 0) {
                this.invalid = true;
            }
            else {
                this.invalid = false;
            }
        }
        return errors;
    }
    get hasDateParts() {
        const parts = this._inputDateParts ||
            DateTimeUtil.parseDateTimeFormat(this.inputFormat);
        return parts.some((p) => p.type === DateParts.Date ||
            p.type === DateParts.Month ||
            p.type === DateParts.Year);
    }
    get hasTimeParts() {
        const parts = this._inputDateParts ||
            DateTimeUtil.parseDateTimeFormat(this.inputFormat);
        return parts.some((p) => p.type === DateParts.Hours ||
            p.type === DateParts.Minutes ||
            p.type === DateParts.Seconds);
    }
    get targetDatePart() {
        var _a;
        let result;
        if (this.hasFocus) {
            const partType = (_a = this._inputDateParts.find((p) => p.start <= this.inputSelection.start &&
                this.inputSelection.start <= p.end &&
                p.type !== DateParts.Literal)) === null || _a === void 0 ? void 0 : _a.type;
            if (partType) {
                result = partType;
            }
        }
        else {
            if (this._inputDateParts.some((p) => p.type === DateParts.Date)) {
                result = DatePart.Date;
            }
            else if (this._inputDateParts.some((p) => p.type === DateParts.Hours)) {
                result = DatePart.Hours;
            }
            else {
                result = this._inputDateParts[0].type;
            }
        }
        return result;
    }
    get datePartDeltas() {
        return Object.assign({}, this._datePartDeltas, this.spinDelta);
    }
    constructor() {
        super();
        this._oldValue = null;
        this._datePartDeltas = {
            date: 1,
            month: 1,
            year: 1,
            hours: 1,
            minutes: 1,
            seconds: 1,
        };
        this.spinLoop = true;
        this.locale = 'en';
        this.addEventListener('wheel', this.onWheel);
    }
    connectedCallback() {
        super.connectedCallback();
        this.updateDefaultMask();
        this.setMask(this.inputFormat);
        if (this.value) {
            this.updateMask();
        }
    }
    reportValidity() {
        const state = this._value
            ? Object.keys(this.validate()).length === 0
            : this.input.reportValidity();
        this.invalid = !state;
        return state;
    }
    checkValidity() {
        if (this.disabled) {
            return this.input.checkValidity();
        }
        if (!this._value) {
            return !this.required;
        }
        return (this.input.checkValidity() && Object.keys(this.validate()).length === 0);
    }
    stepUp(datePart, delta) {
        const targetPart = datePart || this.targetDatePart;
        if (!targetPart) {
            return;
        }
        const newValue = this.trySpinValue(targetPart, delta);
        this.value = newValue;
        this.handleInput();
    }
    stepDown(datePart, delta) {
        const targetPart = datePart || this.targetDatePart;
        if (!targetPart) {
            return;
        }
        const newValue = this.trySpinValue(targetPart, delta, true);
        this.value = newValue;
        this.handleInput();
    }
    clear() {
        this.maskedValue = '';
        this.value = null;
    }
    updateMask() {
        if (this.hasFocus) {
            this.maskedValue = this.getMaskedValue();
        }
        else {
            if (!this.value || !DateTimeUtil.isValidDate(this.value)) {
                this.maskedValue = '';
                return;
            }
            const format = this.displayFormat || this.inputFormat;
            if (this.displayFormat) {
                this.maskedValue = DateTimeUtil.formatDate(this.value, this.locale, format, true);
            }
            else if (this.inputFormat) {
                this.maskedValue = DateTimeUtil.formatDate(this.value, this.locale, format);
            }
            else {
                this.maskedValue = this.value.toLocaleString();
            }
        }
    }
    handleChange() {
        this.emitEvent('igcChange', { detail: this.value });
        this.invalid = !this.checkValidity();
    }
    handleInput() {
        var _a;
        this.emitEvent('igcInput', { detail: (_a = this.value) === null || _a === void 0 ? void 0 : _a.toString() });
    }
    handleDragLeave() {
        if (!this.hasFocus) {
            this.updateMask();
        }
    }
    handleDragEnter() {
        if (!this.hasFocus) {
            this.maskedValue = this.getMaskedValue();
        }
    }
    async updateInput(string, range) {
        var _a;
        const { value, end } = this.parser.replace(this.maskedValue, string, range.start, range.end);
        this.maskedValue = value;
        this.updateValue();
        this.requestUpdate();
        if (range.start !== this.inputFormat.length) {
            this.emitEvent('igcInput', { detail: (_a = this.value) === null || _a === void 0 ? void 0 : _a.toString() });
        }
        await this.updateComplete;
        this.input.setSelectionRange(end, end);
    }
    trySpinValue(datePart, delta, negative = false) {
        if (!delta) {
            delta = this.datePartDeltas[datePart] || 1;
        }
        const spinValue = negative ? -Math.abs(delta) : Math.abs(delta);
        return this.spinValue(datePart, spinValue);
    }
    spinValue(datePart, delta) {
        if (!this.value || !DateTimeUtil.isValidDate(this.value)) {
            return new Date();
        }
        const newDate = new Date(this.value.getTime());
        let formatPart, amPmFromMask;
        switch (datePart) {
            case DatePart.Date:
                DateTimeUtil.spinDate(delta, newDate, this.spinLoop);
                break;
            case DatePart.Month:
                DateTimeUtil.spinMonth(delta, newDate, this.spinLoop);
                break;
            case DatePart.Year:
                DateTimeUtil.spinYear(delta, newDate);
                break;
            case DatePart.Hours:
                DateTimeUtil.spinHours(delta, newDate, this.spinLoop);
                break;
            case DatePart.Minutes:
                DateTimeUtil.spinMinutes(delta, newDate, this.spinLoop);
                break;
            case DatePart.Seconds:
                DateTimeUtil.spinSeconds(delta, newDate, this.spinLoop);
                break;
            case DatePart.AmPm:
                formatPart = this._inputDateParts.find((dp) => dp.type === DateParts.AmPm);
                if (formatPart !== undefined) {
                    amPmFromMask = this.maskedValue.substring(formatPart.start, formatPart.end);
                    return DateTimeUtil.spinAmPm(newDate, this.value, amPmFromMask);
                }
                break;
        }
        return newDate;
    }
    onWheel(event) {
        if (!this.hasFocus) {
            return;
        }
        this.selection = this.inputSelection;
        event.preventDefault();
        event.stopPropagation();
        if (event.deltaY > 0) {
            this.stepDown();
        }
        else {
            this.stepUp();
        }
        this.updateComplete.then(() => this.setSelectionRange(this.selection.start, this.selection.end));
    }
    updateDefaultMask() {
        this._defaultMask = DateTimeUtil.getDefaultMask(this.locale);
    }
    setMask(val) {
        var _a;
        const oldFormat = (_a = this._inputDateParts) === null || _a === void 0 ? void 0 : _a.map((p) => p.format).join('');
        this._inputDateParts = DateTimeUtil.parseDateTimeFormat(val);
        val = this._inputDateParts.map((p) => p.format).join('');
        this._defaultMask = val;
        const newMask = (val || DateTimeUtil.DEFAULT_INPUT_FORMAT).replace(new RegExp(/(?=[^t])[\w]/, 'g'), '0');
        this._mask =
            newMask.indexOf('tt') !== -1
                ? newMask.replace(new RegExp('tt', 'g'), 'LL')
                : newMask;
        this.parser.mask = this._mask;
        this.parser.prompt = this.prompt;
        if (!this.placeholder || oldFormat === this.placeholder) {
            this.placeholder = val;
        }
    }
    parseDate(val) {
        if (!val) {
            return null;
        }
        return DateTimeUtil.parseValueFromMask(val, this._inputDateParts, this.prompt);
    }
    getMaskedValue() {
        let mask = this.emptyMask;
        if (DateTimeUtil.isValidDate(this.value)) {
            for (const part of this._inputDateParts) {
                if (part.type === DateParts.Literal) {
                    continue;
                }
                const targetValue = DateTimeUtil.getPartValue(part, part.format.length, this.value);
                mask = this.parser.replace(mask, targetValue, part.start, part.end).value;
            }
            return mask;
        }
        return this.maskedValue === '' ? mask : this.maskedValue;
    }
    isComplete() {
        return this.maskedValue.indexOf(this.prompt) === -1;
    }
    updateValue() {
        if (this.isComplete()) {
            const parsedDate = this.parseDate(this.maskedValue);
            if (DateTimeUtil.isValidDate(parsedDate)) {
                this.value = parsedDate;
            }
            else {
                this.value = null;
            }
        }
        else {
            this.value = null;
        }
    }
    getNewPosition(value, direction = 0) {
        const literals = this._inputDateParts.filter((p) => p.type === DateParts.Literal);
        let cursorPos = this.selection.start;
        if (!direction) {
            do {
                cursorPos = cursorPos > 0 ? --cursorPos : cursorPos;
            } while (!literals.some((l) => l.end === cursorPos) && cursorPos > 0);
            return cursorPos;
        }
        else {
            do {
                cursorPos++;
            } while (!literals.some((l) => l.start === cursorPos) &&
                cursorPos < value.length);
            return cursorPos;
        }
    }
    handleFocus() {
        this.hasFocus = true;
        this._oldValue = this.value;
        this.updateMask();
        this.emitEvent('igcFocus');
    }
    handleBlur() {
        this.hasFocus = false;
        if (!this.isComplete() && this.maskedValue !== this.emptyMask) {
            const parse = this.parseDate(this.maskedValue);
            if (parse) {
                this.value = parse;
            }
            else {
                this.value = null;
                this.maskedValue = '';
            }
        }
        else {
            this.updateMask();
        }
        if (this._oldValue !== this.value) {
            this.handleChange();
        }
        this.emitEvent('igcBlur');
    }
    handleKeydown(e) {
        super.handleKeydown(e);
        const key = e.key;
        switch (key) {
            case 'ArrowLeft':
            case 'ArrowRight':
                if (e.ctrlKey) {
                    e.preventDefault();
                    const value = e.target.value;
                    const dir = key === 'ArrowRight' ? 1 : 0;
                    const pos = this.getNewPosition(value, dir);
                    this.setSelectionRange(pos, pos);
                }
                break;
            case 'ArrowUp':
            case 'ArrowDown':
                e.preventDefault();
                key === 'ArrowUp' ? this.stepUp() : this.stepDown();
                this.updateComplete.then(() => this.setSelectionRange(this.selection.start, this.selection.end));
                break;
            case ';':
                if (e.ctrlKey) {
                    this.value = new Date();
                }
                break;
        }
    }
    renderInput() {
        return html `
      <input
        type="text"
        part=${partNameMap(this.resolvePartNames('input'))}
        name=${ifDefined(this.name)}
        .value=${live(this.maskedValue)}
        .placeholder=${live(this.placeholder || this.emptyMask)}
        ?readonly=${this.readonly}
        ?disabled=${this.disabled}
        ?required=${this.required}
        @invalid="${this.handleInvalid}"
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @input=${super.handleInput}
        @keydown=${this.handleKeydown}
        @cut=${this.handleCut}
        @compositionstart=${this.handleCompositionStart}
        @compositionend=${this.handleCompositionEnd}
        @dragenter=${this.handleDragEnter}
        @dragleave=${this.handleDragLeave}
        @dragstart=${this.handleDragStart}
      />
    `;
    }
}
IgcDateTimeInputComponent.tagName = 'igc-date-time-input';
__decorate([
    property({ attribute: 'input-format' })
], IgcDateTimeInputComponent.prototype, "inputFormat", null);
__decorate([
    property({
        converter: {
            fromAttribute: (value) => !value ? null : DateTimeUtil.parseIsoDate(value),
            toAttribute: (value) => value.toISOString(),
        },
    }),
    blazorTwoWayBind('igcChange', 'detail')
], IgcDateTimeInputComponent.prototype, "value", null);
__decorate([
    property({
        attribute: 'min-value',
        converter: {
            fromAttribute: (value) => !value ? null : DateTimeUtil.parseIsoDate(value),
            toAttribute: (value) => value.toISOString(),
        },
    })
], IgcDateTimeInputComponent.prototype, "minValue", void 0);
__decorate([
    property({
        attribute: 'max-value',
        converter: {
            fromAttribute: (value) => !value ? null : DateTimeUtil.parseIsoDate(value),
            toAttribute: (value) => value.toISOString(),
        },
    })
], IgcDateTimeInputComponent.prototype, "maxValue", void 0);
__decorate([
    property({ attribute: 'display-format' })
], IgcDateTimeInputComponent.prototype, "displayFormat", void 0);
__decorate([
    property({ attribute: false })
], IgcDateTimeInputComponent.prototype, "spinDelta", void 0);
__decorate([
    property({ type: Boolean, attribute: 'spin-loop' })
], IgcDateTimeInputComponent.prototype, "spinLoop", void 0);
__decorate([
    property()
], IgcDateTimeInputComponent.prototype, "locale", void 0);
__decorate([
    watch('locale', { waitUntilFirstUpdate: true })
], IgcDateTimeInputComponent.prototype, "setDefaultMask", null);
__decorate([
    watch('displayFormat', { waitUntilFirstUpdate: true })
], IgcDateTimeInputComponent.prototype, "setDisplayFormat", null);
__decorate([
    watch('prompt', { waitUntilFirstUpdate: true })
], IgcDateTimeInputComponent.prototype, "promptChange", null);
__decorate([
    watch('required', { waitUntilFirstUpdate: true }),
    watch('disabled', { waitUntilFirstUpdate: true }),
    watch('value', { waitUntilFirstUpdate: true })
], IgcDateTimeInputComponent.prototype, "handleInvalidState", null);
__decorate([
    watch('maxValue'),
    watch('minValue')
], IgcDateTimeInputComponent.prototype, "validate", null);
//# sourceMappingURL=date-time-input.js.map