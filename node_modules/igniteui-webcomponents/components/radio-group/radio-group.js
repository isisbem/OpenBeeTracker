var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, LitElement } from 'lit';
import { property, queryAssignedElements } from 'lit/decorators.js';
import { defineComponents } from '../common/definitions/defineComponents.js';
import { isLTR } from '../common/util.js';
import IgcRadioComponent from '../radio/radio.js';
import { styles } from './radio-group.base.css.js';
import { styles as material } from './radio-group.material.css.js';
import { styles as fluent } from './radio-group.fluent.css.js';
import { themes } from '../../theming/theming-decorator.js';
defineComponents(IgcRadioComponent);
let IgcRadioGroupComponent = class IgcRadioGroupComponent extends LitElement {
    constructor() {
        super();
        this.alignment = 'vertical';
        this.handleKeydown = (event) => {
            const { key } = event;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
                const checked = this.radios.find((radio) => radio.checked);
                let index = this.radios.indexOf(checked);
                const ltr = isLTR(this);
                switch (key) {
                    case 'ArrowUp':
                        index += -1;
                        break;
                    case 'ArrowLeft':
                        index += ltr ? -1 : 1;
                        break;
                    case 'ArrowRight':
                        index += ltr ? 1 : -1;
                        break;
                    default:
                        index += 1;
                }
                if (index < 0)
                    index = this.radios.length - 1;
                if (index > this.radios.length - 1)
                    index = 0;
                this.radios.forEach((radio) => (radio.checked = false));
                this.radios[index].focus();
                this.radios[index].checked = true;
                event.preventDefault();
            }
        };
        this.addEventListener('keydown', this.handleKeydown);
        this.addEventListener('igcChange', this.updateRequiredState);
    }
    updateRequiredState() {
        const hasRequired = this.radios.some((r) => r.required);
        if (hasRequired) {
            this.radios.forEach((r) => (r.required = false));
            const hasChecked = this.radios.some((r) => r.checked);
            if (hasChecked) {
                this.radios.filter((r) => r.checked)[0].required = true;
            }
            else {
                this.radios[0].required = true;
            }
        }
    }
    render() {
        return html `<slot @slotchange=${this.updateRequiredState}></slot>`;
    }
};
IgcRadioGroupComponent.tagName = 'igc-radio-group';
IgcRadioGroupComponent.styles = styles;
__decorate([
    queryAssignedElements({
        flatten: true,
        selector: 'igc-radio:not([disabled])',
    })
], IgcRadioGroupComponent.prototype, "radios", void 0);
__decorate([
    property({ reflect: true })
], IgcRadioGroupComponent.prototype, "alignment", void 0);
IgcRadioGroupComponent = __decorate([
    themes({ material, fluent })
], IgcRadioGroupComponent);
export default IgcRadioGroupComponent;
//# sourceMappingURL=radio-group.js.map