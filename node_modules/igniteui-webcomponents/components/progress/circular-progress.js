var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, nothing, svg } from 'lit';
import { queryAssignedElements } from 'lit/decorators.js';
import { when } from 'lit/directives/when.js';
import { styleMap } from 'lit/directives/style-map.js';
import { asPercent, partNameMap } from '../common/util.js';
import { IgcProgressBaseComponent } from './base.js';
import { styles } from './themes/circular/circular.progress.base.css.js';
import { styles as bootstrap } from './themes/circular/circular.progress.bootstrap.css.js';
import { styles as fluent } from './themes/circular/circular.progress.fluent.css.js';
import { themes } from '../../theming/theming-decorator.js';
import { defineComponents } from '../common/definitions/defineComponents.js';
import IgcCircularGradientComponent from './circular-gradient.js';
defineComponents(IgcCircularGradientComponent);
let IgcCircularProgressComponent = class IgcCircularProgressComponent extends IgcProgressBaseComponent {
    constructor() {
        super(...arguments);
        this.gradientId = Date.now().toString(16);
    }
    get stroke() {
        return {
            stroke: `url(#${this.gradientId})`,
            '--percentage': (asPercent(this.value, this.max) / 100).toString(),
            '--duration': this.animationDuration + 'ms',
        };
    }
    get svgParts() {
        return {
            indeterminate: this.indeterminate,
        };
    }
    gradientChange() {
        this.requestUpdate();
    }
    renderSvg() {
        return svg `
      <circle part="track ${partNameMap(this.svgParts)}"/>
      <circle style="${styleMap(this.stroke)}" part="fill"/>

      <defs>
          <linearGradient id=${this.gradientId} gradientTransform="rotate(90)">
          ${when(this.gradientElements.length, () => this.gradientElements.map((el) => {
            return svg `<stop offset=${el.offset} stop-color=${el.color} stop-opacity=${el.opacity}/>`;
        }), () => svg `
              <stop offset="0%" part="gradient_start" />
              <stop offset="100%" part="gradient_end" />
          `)}
          </linearGradient>
      </defs>
    `;
    }
    renderWrapper() {
        return html `
      <svg
        part="svg ${partNameMap(this.svgParts)}"
        role="progressbar"
        aria-valuemin="0"
        aria-valuemax=${this.max}
        aria-valuenow=${this.indeterminate ? nothing : this.value}
      >
        ${this.renderSvg()}
      </svg>
      <slot name="gradient" @slotchange=${this.gradientChange}></slot>
      ${this.renderDefaultSlot()}
    `;
    }
    render() {
        return this.renderWrapper();
    }
};
IgcCircularProgressComponent.tagName = 'igc-circular-progress';
IgcCircularProgressComponent.styles = styles;
__decorate([
    queryAssignedElements({ slot: 'gradient' })
], IgcCircularProgressComponent.prototype, "gradientElements", void 0);
IgcCircularProgressComponent = __decorate([
    themes({ bootstrap, fluent })
], IgcCircularProgressComponent);
export default IgcCircularProgressComponent;
//# sourceMappingURL=circular-progress.js.map