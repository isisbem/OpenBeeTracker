var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, LitElement } from 'lit';
import { property, query, queryAssignedElements, state, } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { themes } from '../../theming/theming-decorator.js';
import { blazorAdditionalDependencies } from '../common/decorators/blazorAdditionalDependencies.js';
import { blazorSuppress } from '../common/decorators/blazorSuppress.js';
import { watch } from '../common/decorators/watch.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import { SizableMixin } from '../common/mixins/sizable.js';
import { IgcToggleController } from '../toggle/toggle.controller.js';
import { styles } from './themes/light/dropdown.base.css.js';
import { styles as bootstrap } from './themes/light/dropdown.bootstrap.css.js';
import { styles as fluent } from './themes/light/dropdown.fluent.css.js';
import { styles as indigo } from './themes/light/dropdown.indigo.css.js';
import { defineComponents } from '../common/definitions/defineComponents.js';
import IgcDropdownGroupComponent from './dropdown-group.js';
import IgcDropdownHeaderComponent from './dropdown-header.js';
import IgcDropdownItemComponent from './dropdown-item.js';
defineComponents(IgcDropdownGroupComponent, IgcDropdownHeaderComponent, IgcDropdownItemComponent);
let IgcDropdownComponent = class IgcDropdownComponent extends SizableMixin(EventEmitterMixin(LitElement)) {
    get allItems() {
        return [...this.items, ...this.groups.flatMap((group) => group.items)];
    }
    toggleDirectiveChange() {
        var _a;
        if (!this.target)
            return;
        this.toggleController.target = this.target;
        if (this.open) {
            document.addEventListener('keydown', this.handleKeyDown);
            this.target.addEventListener('focusout', this.handleFocusout);
            this.selectedItem = (_a = this.allItems.find((i) => i.selected)) !== null && _a !== void 0 ? _a : null;
        }
        else {
            document.removeEventListener('keydown', this.handleKeyDown);
            this.target.removeEventListener('focusout', this.handleFocusout);
        }
        this.target.setAttribute('aria-expanded', this.open ? 'true' : 'false');
    }
    updateOptions() {
        if (!this.toggleController)
            return;
        this.toggleController.update();
    }
    sizeChange() {
        this.groups.forEach((g) => g.requestUpdate());
    }
    constructor() {
        super();
        this.keyDownHandlers = new Map(Object.entries({
            Escape: this.onEscapeKey,
            Enter: this.onEnterKey,
            ArrowUp: this.onArrowUpKeyDown,
            ArrowDown: this.onArrowDownKeyDown,
            ArrowLeft: this.onArrowUpKeyDown,
            ArrowRight: this.onArrowDownKeyDown,
            Home: this.onHomeKey,
            End: this.onEndKey,
        }));
        this.keepOpenOnSelect = false;
        this.open = false;
        this.placement = 'bottom-start';
        this.positionStrategy = 'absolute';
        this.scrollStrategy = 'scroll';
        this.flip = false;
        this.distance = 0;
        this.keepOpenOnOutsideClick = false;
        this.sameWidth = false;
        this.handleKeyDown = (event) => {
            var _a;
            const path = event.composedPath();
            if (!(path.includes(this.target) || path.includes(this.content)))
                return;
            if (this.keyDownHandlers.has(event.key)) {
                event.preventDefault();
                event.stopPropagation();
                (_a = this.keyDownHandlers.get(event.key)) === null || _a === void 0 ? void 0 : _a.call(this);
            }
        };
        this.handleTargetClick = async () => {
            if (!this.open) {
                if (!this.handleOpening())
                    return;
                this.show();
                await this.updateComplete;
                this.emitEvent('igcOpened');
            }
            else {
                this._hide();
            }
        };
        this.toggleController = new IgcToggleController(this, {
            target: this.target,
            closeCallback: () => this._hide(),
        });
    }
    async firstUpdated() {
        if (this.targetNodes.length) {
            this.target = this.targetNodes[0];
            this.target.setAttribute('aria-haspopup', 'listbox');
        }
        await this.updateComplete;
        this.setInitialSelection();
    }
    async getUpdateComplete() {
        const result = await super.getUpdateComplete();
        await this.toggleController.rendered;
        return result;
    }
    setInitialSelection() {
        const item = this.allItems.filter((item) => item.selected).at(-1);
        this.allItems.forEach((item) => (item.selected = false));
        if (item) {
            this.selectItem(item, false);
        }
    }
    onHomeKey() {
        this.navigateTo(this.allItems.filter((item) => !item.disabled).at(0).value);
    }
    onEndKey() {
        this.navigateTo(this.allItems.filter((item) => !item.disabled).at(-1).value);
    }
    onEscapeKey() {
        this._hide();
    }
    onEnterKey() {
        this.selectItem(this.activeItem);
    }
    handleClick(event) {
        const item = event
            .composedPath()
            .find((e) => e instanceof IgcDropdownItemComponent);
        if (!item || item.disabled)
            return;
        this.selectItem(item);
    }
    handleOpening() {
        const args = { cancelable: true };
        return this.emitEvent('igcOpening', args);
    }
    handleClosing() {
        const args = { cancelable: true };
        return this.emitEvent('igcClosing', args);
    }
    handleChange(item) {
        const args = { detail: item };
        this.emitEvent('igcChange', args);
    }
    handleSlotChange() {
        if (!this.target)
            return;
        this.target.setAttribute('aria-expanded', this.open ? 'true' : 'false');
    }
    handleFocusout(event) {
        event.preventDefault();
        event.target.focus();
    }
    getItem(value) {
        let itemIndex = -1;
        let item;
        this.allItems.find((i, index) => {
            if (i.value === value) {
                item = i;
                itemIndex = index;
            }
        });
        return { item: item, index: itemIndex };
    }
    activateItem(value) {
        if (!value)
            return;
        if (this.activeItem) {
            this.activeItem.active = false;
        }
        this.activeItem = value;
        this.activeItem.active = true;
    }
    selectItem(item, emit = true) {
        if (!item)
            return null;
        if (this.selectedItem) {
            this.selectedItem.selected = false;
        }
        this.activateItem(item);
        this.selectedItem = item;
        this.selectedItem.selected = true;
        if (emit)
            this.handleChange(this.selectedItem);
        if (emit && !this.keepOpenOnSelect)
            this._hide();
        return this.selectedItem;
    }
    navigate(direction, currentIndex) {
        var _a;
        let index = -1;
        if (this.activeItem) {
            index = currentIndex
                ? currentIndex
                : (_a = [...this.allItems].indexOf(this.activeItem)) !== null && _a !== void 0 ? _a : index;
        }
        const newIndex = this.getNearestSiblingFocusableItemIndex(index, direction);
        this.navigateItem(newIndex);
    }
    navigateItem(newIndex) {
        if (!this.allItems) {
            return null;
        }
        if (newIndex < 0 || newIndex >= this.allItems.length) {
            return null;
        }
        const newItem = this.allItems[newIndex];
        this.activateItem(newItem);
        this.scrollToHiddenItem(newItem);
        return newItem;
    }
    scrollToHiddenItem(newItem) {
        const elementRect = newItem.getBoundingClientRect();
        const parentRect = this.content.getBoundingClientRect();
        if (parentRect.top > elementRect.top) {
            this.content.scrollTop -= parentRect.top - elementRect.top;
        }
        if (parentRect.bottom < elementRect.bottom) {
            this.content.scrollTop += elementRect.bottom - parentRect.bottom;
        }
    }
    getNearestSiblingFocusableItemIndex(startIndex, direction) {
        let index = startIndex;
        const items = this.allItems;
        if (!items) {
            return -1;
        }
        while (items[index + direction] && items[index + direction].disabled) {
            index += direction;
        }
        index += direction;
        return index > -1 && index < items.length ? index : -1;
    }
    navigateNext() {
        this.navigate(1);
    }
    navigatePrev() {
        this.navigate(-1);
    }
    onArrowDownKeyDown() {
        this.navigateNext();
    }
    onArrowUpKeyDown() {
        this.navigatePrev();
    }
    async _hide(emit = true) {
        if (!this.open)
            return;
        if (emit && !this.handleClosing())
            return;
        this.open = false;
        if (emit) {
            await this.updateComplete;
            this.emitEvent('igcClosed');
        }
    }
    show(target) {
        if (this.open && !target)
            return;
        if (target)
            this.target = target;
        this.open = true;
    }
    hide() {
        this._hide(false);
    }
    toggle(target) {
        this.open ? this.hide() : this.show(target);
    }
    navigateTo(value) {
        const index = typeof value === 'string' ? this.getItem(value).index : value;
        return this.navigateItem(index);
    }
    select(value) {
        const item = typeof value === 'string'
            ? this.getItem(value).item
            : this.allItems[value];
        return this.selectItem(item, false);
    }
    clearSelection() {
        if (this.selectedItem) {
            this.selectedItem.selected = false;
        }
        this.selectedItem = null;
    }
    render() {
        return html `
      <slot
        id="igcDDLTarget"
        name="target"
        @click=${this.handleTargetClick}
        @slotchange=${this.handleSlotChange}
      >
      </slot>
      <div
        part="base"
        style=${styleMap({ position: this.positionStrategy })}
        @click=${this.handleClick}
        ${this.toggleController.toggleDirective}
      >
        <div role="listbox" part="list" aria-labelledby="igcDDLTarget">
          <slot></slot>
        </div>
      </div>
    `;
    }
};
IgcDropdownComponent.tagName = 'igc-dropdown';
IgcDropdownComponent.styles = styles;
__decorate([
    state()
], IgcDropdownComponent.prototype, "activeItem", void 0);
__decorate([
    queryAssignedElements({ slot: 'target' })
], IgcDropdownComponent.prototype, "targetNodes", void 0);
__decorate([
    query('[part="base"]')
], IgcDropdownComponent.prototype, "content", void 0);
__decorate([
    query('[part="list"]')
], IgcDropdownComponent.prototype, "scrollContainer", void 0);
__decorate([
    queryAssignedElements({ flatten: true, selector: 'igc-dropdown-item' })
], IgcDropdownComponent.prototype, "items", void 0);
__decorate([
    queryAssignedElements({ flatten: true, selector: 'igc-dropdown-group' })
], IgcDropdownComponent.prototype, "groups", void 0);
__decorate([
    property({ type: Boolean, attribute: 'keep-open-on-select' })
], IgcDropdownComponent.prototype, "keepOpenOnSelect", void 0);
__decorate([
    property({ type: Boolean })
], IgcDropdownComponent.prototype, "open", void 0);
__decorate([
    property()
], IgcDropdownComponent.prototype, "placement", void 0);
__decorate([
    property({ attribute: 'position-strategy' })
], IgcDropdownComponent.prototype, "positionStrategy", void 0);
__decorate([
    property({ attribute: 'scroll-strategy' })
], IgcDropdownComponent.prototype, "scrollStrategy", void 0);
__decorate([
    property({ type: Boolean })
], IgcDropdownComponent.prototype, "flip", void 0);
__decorate([
    property({ type: Number })
], IgcDropdownComponent.prototype, "distance", void 0);
__decorate([
    property({ type: Boolean, attribute: 'keep-open-on-outside-click' })
], IgcDropdownComponent.prototype, "keepOpenOnOutsideClick", void 0);
__decorate([
    property({ type: Boolean, attribute: 'same-width' })
], IgcDropdownComponent.prototype, "sameWidth", void 0);
__decorate([
    watch('open')
], IgcDropdownComponent.prototype, "toggleDirectiveChange", null);
__decorate([
    watch('placement'),
    watch('flip'),
    watch('positionStrategy'),
    watch('closeOnOutsideClick'),
    watch('distance'),
    watch('sameWidth')
], IgcDropdownComponent.prototype, "updateOptions", null);
__decorate([
    watch('size')
], IgcDropdownComponent.prototype, "sizeChange", null);
__decorate([
    blazorSuppress()
], IgcDropdownComponent.prototype, "show", null);
__decorate([
    blazorSuppress()
], IgcDropdownComponent.prototype, "toggle", null);
__decorate([
    blazorSuppress()
], IgcDropdownComponent.prototype, "navigateTo", null);
__decorate([
    blazorSuppress()
], IgcDropdownComponent.prototype, "select", null);
IgcDropdownComponent = __decorate([
    themes({ bootstrap, fluent, indigo }),
    blazorAdditionalDependencies('IgcDropdownItemComponent, IgcDropdownHeaderComponent, IgcDropdownGroupComponent')
], IgcDropdownComponent);
export default IgcDropdownComponent;
//# sourceMappingURL=dropdown.js.map