var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html } from 'lit';
import { property, query, queryAssignedElements, state, } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { styleMap } from 'lit/directives/style-map.js';
import { themes } from '../../theming/index.js';
import { blazorAdditionalDependencies } from '../common/decorators/blazorAdditionalDependencies.js';
import { watch } from '../common/decorators/watch.js';
import { defineComponents } from '../common/definitions/defineComponents.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import IgcDropdownComponent from '../dropdown/dropdown.js';
import IgcIconComponent from '../icon/icon.js';
import IgcInputComponent from '../input/input.js';
import IgcSelectGroupComponent from './select-group.js';
import IgcSelectHeaderComponent from './select-header.js';
import IgcSelectItemComponent from './select-item.js';
import { styles } from './themes/light/select.base.css.js';
import { styles as bootstrap } from './themes/light/select.bootstrap.css.js';
import { styles as fluent } from './themes/light/select.fluent.css.js';
import { styles as indigo } from './themes/light/select.indigo.css.js';
import { styles as material } from './themes/light/select.material.css.js';
import { alternateName } from '../common/decorators/alternateName.js';
defineComponents(IgcIconComponent, IgcInputComponent, IgcSelectGroupComponent, IgcSelectHeaderComponent, IgcSelectItemComponent);
let IgcSelectComponent = class IgcSelectComponent extends EventEmitterMixin(IgcDropdownComponent) {
    constructor() {
        super();
        this.searchTerm = '';
        this.lastKeyTime = Date.now();
        this.targetKeyHandlers = new Map(Object.entries({
            ' ': this.onTargetEnterKey,
            Tab: this.onTargetTabKey,
            Escape: this.onEscapeKey,
            Enter: this.onTargetEnterKey,
            ArrowLeft: this.onTargetArrowLeftKeyDown,
            ArrowRight: this.onTargetArrowRightKeyDown,
            ArrowUp: this.onTargetArrowUpKeyDown,
            ArrowDown: this.onTargetArrowDownKeyDown,
            Home: this.onTargetHomeKey,
            End: this.onTargetEndKey,
        }));
        this.disabled = false;
        this.required = false;
        this.invalid = false;
        this.outlined = false;
        this.sameWidth = true;
        this.dir = 'auto';
        this.size = 'medium';
        this.addEventListener('igcChange', () => {
            if (this.open)
                this.target.focus();
        });
    }
    themeAdopted(controller) {
        this.themeController = controller;
    }
    willUpdate(changes) {
        super.willUpdate(changes);
        this.theme = this.themeController.theme;
    }
    handleFocusout() { }
    focus(options) {
        this.target.focus(options);
    }
    blur() {
        this.target.blur();
    }
    reportValidity() {
        const valid = this.checkValidity();
        if (!valid)
            this.target.focus();
        return valid;
    }
    checkValidity() {
        this.invalid = this.required && !this.value;
        return !this.invalid;
    }
    async firstUpdated() {
        super.firstUpdated();
        await this.updateComplete;
        if (!this.selectedItem && this.value) {
            this.updateSelected();
        }
        if (this.autofocus) {
            this.target.focus();
        }
    }
    updateValue() {
        var _a;
        this.value = (_a = this.selectedItem) === null || _a === void 0 ? void 0 : _a.value;
    }
    updateSelected() {
        var _a;
        if (this.allItems.length === 0)
            return;
        if (((_a = this.selectedItem) === null || _a === void 0 ? void 0 : _a.value) !== this.value) {
            const matches = this.allItems.filter((i) => i.value === this.value);
            const index = this.allItems.indexOf(matches.at(-1));
            if (index === -1) {
                this.value = undefined;
                this.clearSelection();
                return;
            }
            this.select(index);
        }
    }
    validate() {
        this.updateComplete.then(() => this.reportValidity());
    }
    selectNext() {
        var _a;
        const activeItemIndex = [...this.allItems].indexOf((_a = this.selectedItem) !== null && _a !== void 0 ? _a : this.activeItem);
        const next = this.getNearestSiblingFocusableItemIndex(activeItemIndex !== null && activeItemIndex !== void 0 ? activeItemIndex : -1, 1);
        this.selectItem(this.allItems[next], true);
    }
    selectPrev() {
        var _a;
        const activeItemIndex = [...this.allItems].indexOf((_a = this.selectedItem) !== null && _a !== void 0 ? _a : this.activeItem);
        const prev = this.getNearestSiblingFocusableItemIndex(activeItemIndex !== null && activeItemIndex !== void 0 ? activeItemIndex : -1, -1);
        this.selectItem(this.allItems[prev], true);
    }
    selectInteractiveItem(index) {
        const item = this.allItems
            .filter((i) => !i.disabled)
            .at(index);
        if (item.value !== this.value) {
            this.selectItem(item, true);
        }
    }
    searchItem(event) {
        if (!/^.$/u.test(event.key)) {
            return;
        }
        const currentTime = Date.now();
        if (currentTime - this.lastKeyTime > 500) {
            this.searchTerm = '';
        }
        this.searchTerm += event.key;
        this.lastKeyTime = currentTime;
        const item = this.allItems
            .filter((i) => !i.disabled)
            .find((i) => {
            var _a;
            return (_a = i.textContent) === null || _a === void 0 ? void 0 : _a.trim().toLowerCase().startsWith(this.searchTerm.toLowerCase());
        });
        if (item && this.value !== item.value) {
            this.open ? this.activateItem(item) : this.selectItem(item);
        }
    }
    handleFocus() {
        if (this.open)
            return;
        this.emitEvent('igcFocus');
    }
    handleBlur() {
        if (this.open)
            return;
        this.emitEvent('igcBlur');
    }
    onTargetTabKey() {
        this.target.blur();
        if (this.open)
            this.hide();
    }
    onTargetEnterKey() {
        !this.open ? this.target.click() : this.onEnterKey();
    }
    onTargetArrowLeftKeyDown() {
        !this.open ? this.selectPrev() : this.onArrowUpKeyDown();
    }
    onTargetArrowRightKeyDown() {
        !this.open ? this.selectNext() : this.onArrowDownKeyDown();
    }
    onTargetArrowUpKeyDown(event) {
        if (event.altKey) {
            this.toggle();
        }
        else {
            !this.open ? this.selectPrev() : this.onArrowUpKeyDown();
        }
    }
    onTargetArrowDownKeyDown(event) {
        if (event.altKey) {
            this.toggle();
        }
        else {
            !this.open ? this.selectNext() : this.onArrowDownKeyDown();
        }
    }
    onTargetHomeKey() {
        !this.open ? this.selectInteractiveItem(0) : this.onHomeKey();
    }
    onTargetEndKey() {
        !this.open ? this.selectInteractiveItem(-1) : this.onEndKey();
    }
    handleTargetKeyDown(event) {
        var _a;
        event.stopPropagation();
        if (this.targetKeyHandlers.has(event.key)) {
            event.preventDefault();
            (_a = this.targetKeyHandlers.get(event.key)) === null || _a === void 0 ? void 0 : _a.call(this, event);
        }
        else {
            this.searchItem(event);
        }
    }
    get hasPrefixes() {
        return this.inputPrefix.length > 0;
    }
    get hasSuffixes() {
        return this.inputSuffix.length > 0;
    }
    render() {
        var _a, _b;
        const openIcon = this.theme === 'material' ? 'keyboard_arrow_up' : 'arrow_drop_up';
        const closeIcon = this.theme === 'material' ? 'keyboard_arrow_down' : 'arrow_drop_down';
        return html `
      <div
        role="combobox"
        tabindex=${this.disabled ? -1 : 0}
        aria-owns="dropdown"
        aria-describedby="helper-text"
        aria-disabled=${this.disabled}
        @focusin=${this.handleFocus}
        @focusout=${this.handleBlur}
        @keydown=${this.handleTargetKeyDown}
        @click=${this.handleTargetClick}
      >
        <igc-input
          id="input"
          readonly
          exportparts="container: input, input: native-input, label, prefix, suffix"
          value=${ifDefined((_b = (_a = this.selectedItem) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim())}
          placeholder=${ifDefined(this.placeholder)}
          label=${ifDefined(this.label)}
          size=${this.size}
          dir=${this.dir}
          tabindex="-1"
          .disabled="${this.disabled}"
          .required=${this.required}
          .invalid=${this.invalid}
          .outlined=${this.outlined}
          @igcBlur=${(e) => e.stopPropagation()}
          @igcFocus=${(e) => e.stopPropagation()}
        >
          <span slot=${this.hasPrefixes ? 'prefix' : ''}>
            <slot name="prefix"></slot>
          </span>
          <span slot=${this.hasSuffixes ? 'suffix' : ''}>
            <slot name="suffix"></slot>
          </span>
          <span slot="suffix" part="toggle-icon" style="display: flex">
            <slot name="toggle-icon">
              <igc-icon
                size=${this.size}
                name=${this.open ? openIcon : closeIcon}
                collection="internal"
                aria-hidden="true"
              ></igc-icon>
            </slot>
          </span>
        </igc-input>
      </div>
      <div
        id="helper-text"
        part="helper-text"
        ?hidden="${this.helperText.length === 0}"
      >
        <slot name="helper-text"></slot>
      </div>
      <div
        part="base"
        style=${styleMap({ position: this.positionStrategy })}
        @click=${this.handleClick}
        ${this.toggleController.toggleDirective}
      >
        <div id="dropdown" role="listbox" part="list" aria-labelledby="input">
          <slot name="header"></slot>
          <slot></slot>
          <slot name="footer"></slot>
        </div>
      </div>
    `;
    }
};
IgcSelectComponent.tagName = 'igc-select';
IgcSelectComponent.styles = styles;
__decorate([
    queryAssignedElements({ flatten: true, selector: 'igc-select-item' })
], IgcSelectComponent.prototype, "items", void 0);
__decorate([
    queryAssignedElements({ flatten: true, selector: 'igc-select-group' })
], IgcSelectComponent.prototype, "groups", void 0);
__decorate([
    queryAssignedElements({ slot: 'helper-text' })
], IgcSelectComponent.prototype, "helperText", void 0);
__decorate([
    queryAssignedElements({ slot: 'suffix' })
], IgcSelectComponent.prototype, "inputSuffix", void 0);
__decorate([
    queryAssignedElements({ slot: 'prefix' })
], IgcSelectComponent.prototype, "inputPrefix", void 0);
__decorate([
    state()
], IgcSelectComponent.prototype, "selectedItem", void 0);
__decorate([
    query('div[role="combobox"]')
], IgcSelectComponent.prototype, "target", void 0);
__decorate([
    property({ reflect: false, type: String })
], IgcSelectComponent.prototype, "value", void 0);
__decorate([
    property()
], IgcSelectComponent.prototype, "name", void 0);
__decorate([
    property({ reflect: true, type: Boolean })
], IgcSelectComponent.prototype, "disabled", void 0);
__decorate([
    property({ reflect: true, type: Boolean })
], IgcSelectComponent.prototype, "required", void 0);
__decorate([
    property({ reflect: true, type: Boolean })
], IgcSelectComponent.prototype, "invalid", void 0);
__decorate([
    property({ reflect: true, type: Boolean })
], IgcSelectComponent.prototype, "outlined", void 0);
__decorate([
    property({ type: Boolean })
], IgcSelectComponent.prototype, "autofocus", void 0);
__decorate([
    property()
], IgcSelectComponent.prototype, "label", void 0);
__decorate([
    property()
], IgcSelectComponent.prototype, "placeholder", void 0);
__decorate([
    property({ type: Boolean, attribute: 'same-width' })
], IgcSelectComponent.prototype, "sameWidth", void 0);
__decorate([
    property({ reflect: true })
], IgcSelectComponent.prototype, "dir", void 0);
__decorate([
    alternateName('focusComponent')
], IgcSelectComponent.prototype, "focus", null);
__decorate([
    alternateName('blurComponent')
], IgcSelectComponent.prototype, "blur", null);
__decorate([
    watch('selectedItem')
], IgcSelectComponent.prototype, "updateValue", null);
__decorate([
    watch('value')
], IgcSelectComponent.prototype, "updateSelected", null);
__decorate([
    watch('value')
], IgcSelectComponent.prototype, "validate", null);
IgcSelectComponent = __decorate([
    themes({ bootstrap, material, fluent, indigo }),
    blazorAdditionalDependencies('IgcIconComponent, IgcInputComponent, IgcSelectGroupComponent, IgcSelectHeaderComponent, IgcSelectItemComponent')
], IgcSelectComponent);
export default IgcSelectComponent;
//# sourceMappingURL=select.js.map