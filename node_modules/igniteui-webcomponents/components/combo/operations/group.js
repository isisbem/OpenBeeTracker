export default class GroupDataOperation {
    constructor() {
        this.orderBy = new Map(Object.entries({
            asc: 1,
            desc: -1,
        }));
    }
    resolveValue(record, key) {
        return record[key];
    }
    compareValues(first, second) {
        if (typeof first === 'string' && typeof second === 'string') {
            return first.localeCompare(second);
        }
        return first > second ? 1 : first < second ? -1 : 0;
    }
    compareObjects(first, second, key, direction) {
        const [a, b] = [
            this.resolveValue(first, key),
            this.resolveValue(second, key),
        ];
        return this.orderBy.get(direction) * this.compareValues(a, b);
    }
    apply(data, controller) {
        const { groupingOptions: { groupKey, valueKey, displayKey, direction }, } = controller;
        if (!groupKey)
            return data;
        const groups = new Map();
        data.forEach((item) => {
            var _a, _b;
            if (typeof item !== 'object' || item === null)
                return;
            const key = (_a = item[groupKey]) !== null && _a !== void 0 ? _a : 'Other';
            const group = (_b = groups.get(key)) !== null && _b !== void 0 ? _b : [];
            if (group.length === 0) {
                group.push({
                    [valueKey]: key,
                    [displayKey]: key,
                    [groupKey]: key,
                    header: true,
                });
            }
            group.push(item);
            groups.set(key, group);
        });
        groups.forEach((group) => {
            group.sort((a, b) => {
                if (a.header || b.header)
                    return;
                return this.compareObjects(a, b, displayKey, direction);
            });
        });
        return Array.from(groups.values()).flat();
    }
}
//# sourceMappingURL=group.js.map