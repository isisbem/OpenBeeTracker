var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, LitElement } from 'lit';
import { property, queryAssignedElements } from 'lit/decorators.js';
import { defineComponents } from '../common/definitions/defineComponents.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import { SizableMixin } from '../common/mixins/sizable.js';
import IgcStepComponent from './step.js';
import { themes } from '../../theming/theming-decorator.js';
import { styles } from './themes/stepper/stepper.base.css.js';
import { styles as bootstrap } from './themes/stepper/stepper.bootstrap.css.js';
import { styles as fluent } from './themes/stepper/stepper.fluent.css.js';
import { styles as indigo } from './themes/stepper/stepper.indigo.css.js';
import { watch } from '../common/decorators/watch.js';
defineComponents(IgcStepComponent);
let IgcStepperComponent = class IgcStepperComponent extends SizableMixin(EventEmitterMixin(LitElement)) {
    orientationChange() {
        this.setAttribute('aria-orientation', this.orientation);
        this.steps.forEach((step) => (step.orientation = this.orientation));
    }
    stepTypeChange() {
        this.steps.forEach((step) => (step.stepType = this.stepType));
    }
    titlePositionChange() {
        this.steps.forEach((step) => (step.titlePosition = this.titlePosition));
    }
    contentTopChange() {
        this.steps.forEach((step) => (step.contentTop = this.contentTop));
    }
    linearChange() {
        this.steps.forEach((step) => {
            step.linearDisabled = this.linear;
            if (step.index <= this.activeStep.index) {
                step.visited = true;
            }
            else {
                step.visited = false;
            }
        });
        if (this.linear) {
            this.updateStepsLinearDisabled();
        }
    }
    constructor() {
        super();
        this.keyDownHandlers = new Map(Object.entries({
            Enter: this.activateStep,
            Space: this.activateStep,
            SpaceBar: this.activateStep,
            ' ': this.activateStep,
            ArrowUp: this.onArrowUpKeyDown,
            ArrowDown: this.onArrowDownKeyDown,
            ArrowLeft: this.onArrowLeftKeyDown,
            ArrowRight: this.onArrowRightKeyDown,
            Home: this.onHomeKey,
            End: this.onEndKey,
        }));
        this.orientation = 'horizontal';
        this.stepType = 'full';
        this.linear = false;
        this.contentTop = false;
        this.dir = 'auto';
        this.addEventListener('stepActiveChanged', (event) => {
            event.stopPropagation();
            this.activateStep(event.target, event.detail);
        });
        this.addEventListener('stepDisabledInvalidChanged', (event) => {
            event.stopPropagation();
            if (this.linear) {
                this.updateStepsLinearDisabled();
            }
        });
        this.addEventListener('stepCompleteChanged', (event) => {
            event.stopPropagation();
            const nextStep = this.steps[event.target.index + 1];
            if (nextStep) {
                nextStep.previousComplete = event.target.complete;
            }
        });
        this.addEventListener('stepHeaderKeydown', (event) => {
            event.stopPropagation();
            this.handleKeydown(event.detail.event, event.detail.focusedStep);
        });
    }
    connectedCallback() {
        super.connectedCallback();
        this.setAttribute('role', 'tablist');
        this.setAttribute('aria-orientation', this.orientation);
    }
    activateFirstStep() {
        const firstEnabledStep = this.steps.find((s) => !s.disabled);
        if (firstEnabledStep) {
            this.activateStep(firstEnabledStep, false);
        }
    }
    activateStep(step, shouldEmit = true) {
        if (step === this.activeStep) {
            return;
        }
        if (shouldEmit) {
            const args = {
                detail: {
                    owner: this,
                    oldIndex: this.activeStep.index,
                    newIndex: step.index,
                },
                cancelable: true,
            };
            const allowed = this.emitEvent('igcActiveStepChanging', args);
            if (!allowed) {
                return;
            }
            this.changeActiveStep(step);
            this.emitEvent('igcActiveStepChanged', {
                detail: { owner: this, index: step.index },
            });
        }
        else {
            this.changeActiveStep(step);
        }
    }
    changeActiveStep(step) {
        if (this.activeStep) {
            this.activeStep.active = false;
        }
        step.active = true;
        step.visited = true;
        this.activeStep = step;
    }
    moveToNextStep(next = true) {
        let steps = this.steps;
        let activeStepIndex = this.activeStep.index;
        if (!next) {
            steps = this.steps.reverse();
            activeStepIndex = steps.findIndex((step) => step === this.activeStep);
        }
        const nextStep = steps.find((step, i) => i > activeStepIndex && step.isAccessible);
        if (nextStep) {
            this.activateStep(nextStep, false);
        }
    }
    handleKeydown(event, focusedStep) {
        var _a;
        const key = event.key.toLowerCase();
        if (this.keyDownHandlers.has(event.key)) {
            event.preventDefault();
            (_a = this.keyDownHandlers.get(event.key)) === null || _a === void 0 ? void 0 : _a.call(this, focusedStep);
        }
        if (key === 'tab' && this.orientation === 'vertical') {
            return;
        }
        if (key === 'tab' && this.activeStep.index !== focusedStep.index) {
            this.activeStep.header.focus();
        }
    }
    onHomeKey() {
        var _a, _b;
        (_b = (_a = this.steps
            .filter((step) => step.isAccessible)[0]) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.focus();
    }
    onEndKey() {
        var _a, _b;
        (_b = (_a = this.steps
            .filter((step) => step.isAccessible)
            .pop()) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.focus();
    }
    onArrowDownKeyDown(focusedStep) {
        var _a, _b;
        if (this.orientation === 'horizontal') {
            return;
        }
        (_b = (_a = this.getNextStep(focusedStep)) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.focus();
    }
    onArrowUpKeyDown(focusedStep) {
        var _a, _b;
        if (this.orientation === 'horizontal') {
            return;
        }
        (_b = (_a = this.getPreviousStep(focusedStep)) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.focus();
    }
    onArrowRightKeyDown(focusedStep) {
        var _a, _b, _c, _d;
        if (this.dir === 'rtl' && this.orientation === 'horizontal') {
            (_b = (_a = this.getPreviousStep(focusedStep)) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.focus();
        }
        else {
            (_d = (_c = this.getNextStep(focusedStep)) === null || _c === void 0 ? void 0 : _c.header) === null || _d === void 0 ? void 0 : _d.focus();
        }
    }
    onArrowLeftKeyDown(focusedStep) {
        var _a, _b, _c, _d;
        if (this.dir === 'rtl' && this.orientation === 'horizontal') {
            (_b = (_a = this.getNextStep(focusedStep)) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.focus();
        }
        else {
            (_d = (_c = this.getPreviousStep(focusedStep)) === null || _c === void 0 ? void 0 : _c.header) === null || _d === void 0 ? void 0 : _d.focus();
        }
    }
    getNextStep(focusedStep) {
        if (focusedStep.index === this.steps.length - 1) {
            return this.steps.find((step) => step.isAccessible);
        }
        const nextAccessible = this.steps.find((step, i) => i > focusedStep.index && step.isAccessible);
        return nextAccessible
            ? nextAccessible
            : this.steps.find((step) => step.isAccessible);
    }
    getPreviousStep(focusedStep) {
        if (focusedStep.index === 0) {
            return this.steps
                .filter((step) => step.isAccessible)
                .pop();
        }
        let prevStep;
        for (let i = focusedStep.index - 1; i >= 0; i--) {
            const step = this.steps[i];
            if (step.isAccessible) {
                prevStep = step;
                break;
            }
        }
        return prevStep
            ? prevStep
            : this.steps.filter((step) => step.isAccessible).pop();
    }
    updateStepsLinearDisabled() {
        const firstInvalidStep = this.steps
            .filter((step) => !step.disabled && !step.optional)
            .find((step) => step.invalid);
        if (firstInvalidStep) {
            this.steps.forEach((step) => {
                if (step.index <= firstInvalidStep.index) {
                    step.linearDisabled = false;
                }
                else {
                    step.linearDisabled = true;
                }
            });
        }
        else {
            this.steps.forEach((step) => (step.linearDisabled = false));
        }
    }
    syncProperties() {
        this.steps.forEach((step, index) => {
            var _a, _b, _c, _d;
            step.orientation = this.orientation;
            step.stepType = this.stepType;
            step.titlePosition = this.titlePosition;
            step.contentTop = this.contentTop;
            step.index = index;
            step.active = this.activeStep === step;
            (_a = step.header) === null || _a === void 0 ? void 0 : _a.setAttribute('aria-posinset', (index + 1).toString());
            (_b = step.header) === null || _b === void 0 ? void 0 : _b.setAttribute('aria-setsize', this.steps.length.toString());
            (_c = step.header) === null || _c === void 0 ? void 0 : _c.setAttribute('id', `igc-step-header-${index}`);
            (_d = step.header) === null || _d === void 0 ? void 0 : _d.setAttribute('aria-controls', `igc-step-content-${index}`);
            if (index > 0) {
                step.previousComplete = this.steps[index - 1].complete;
            }
        });
    }
    stepsChanged() {
        this.style.setProperty('--steps-count', this.steps.length.toString());
        const lastActiveStep = this.steps
            .reverse()
            .find((step) => step.active);
        if (!lastActiveStep) {
            this.activateFirstStep();
        }
        else {
            this.activateStep(lastActiveStep, false);
        }
        this.syncProperties();
        if (this.linear) {
            this.updateStepsLinearDisabled();
        }
    }
    navigateTo(index) {
        const step = this.steps[index];
        if (!step) {
            return;
        }
        this.activateStep(step, false);
    }
    next() {
        this.moveToNextStep();
    }
    prev() {
        this.moveToNextStep(false);
    }
    reset() {
        this.steps.forEach((step) => (step.visited = false));
        this.activateFirstStep();
    }
    render() {
        return html `<slot @slotchange=${this.stepsChanged}></slot>`;
    }
};
IgcStepperComponent.tagName = 'igc-stepper';
IgcStepperComponent.styles = styles;
__decorate([
    queryAssignedElements({ selector: 'igc-step' })
], IgcStepperComponent.prototype, "steps", void 0);
__decorate([
    property({ reflect: true })
], IgcStepperComponent.prototype, "orientation", void 0);
__decorate([
    property({ reflect: true, attribute: 'step-type' })
], IgcStepperComponent.prototype, "stepType", void 0);
__decorate([
    property({ type: Boolean })
], IgcStepperComponent.prototype, "linear", void 0);
__decorate([
    property({ reflect: true, type: Boolean, attribute: 'content-top' })
], IgcStepperComponent.prototype, "contentTop", void 0);
__decorate([
    property({ reflect: true })
], IgcStepperComponent.prototype, "dir", void 0);
__decorate([
    property({ reflect: false, attribute: 'title-position' })
], IgcStepperComponent.prototype, "titlePosition", void 0);
__decorate([
    watch('orientation', { waitUntilFirstUpdate: true })
], IgcStepperComponent.prototype, "orientationChange", null);
__decorate([
    watch('stepType', { waitUntilFirstUpdate: true })
], IgcStepperComponent.prototype, "stepTypeChange", null);
__decorate([
    watch('titlePosition', { waitUntilFirstUpdate: true })
], IgcStepperComponent.prototype, "titlePositionChange", null);
__decorate([
    watch('contentTop', { waitUntilFirstUpdate: true })
], IgcStepperComponent.prototype, "contentTopChange", null);
__decorate([
    watch('linear', { waitUntilFirstUpdate: true })
], IgcStepperComponent.prototype, "linearChange", null);
IgcStepperComponent = __decorate([
    themes({ bootstrap, fluent, indigo })
], IgcStepperComponent);
export default IgcStepperComponent;
//# sourceMappingURL=stepper.js.map