var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var IgcTabsComponent_1;
import { html, LitElement, nothing } from 'lit';
import { eventOptions, property, query, queryAssignedElements, state, } from 'lit/decorators.js';
import { watch } from '../common/decorators/watch.js';
import { blazorAdditionalDependencies } from '../common/decorators/blazorAdditionalDependencies.js';
import { themes } from '../../theming/theming-decorator.js';
import { styles } from './themes/light/tabs.base.css.js';
import { styles as bootstrap } from './themes/light/tabs.bootstrap.css.js';
import { styles as fluent } from './themes/light/tabs.fluent.css.js';
import { styles as indigo } from './themes/light/tabs.indigo.css.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import { createCounter, getOffset, isLTR } from '../common/util.js';
import { getAttributesForTags, getNodesForTags, observerConfig, } from './utils.js';
import { defineComponents } from '../common/definitions/defineComponents.js';
import IgcTabComponent from './tab.js';
import IgcTabPanelComponent from './tab-panel.js';
import IgcIconButtonComponent from '../button/icon-button.js';
defineComponents(IgcTabComponent, IgcTabPanelComponent, IgcIconButtonComponent);
let IgcTabsComponent = IgcTabsComponent_1 = class IgcTabsComponent extends EventEmitterMixin(LitElement) {
    constructor() {
        super(...arguments);
        this.showScrollButtons = false;
        this.disableStartScrollButton = true;
        this.disableEndScrollButton = false;
        this.alignment = 'start';
        this.activation = 'auto';
        this.handleKeyDown = (event) => {
            var _a;
            const { key } = event;
            const enabledTabs = this.enabledTabs;
            const ltr = isLTR(this);
            let index = enabledTabs.indexOf((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.closest('igc-tab'));
            switch (key) {
                case 'ArrowLeft':
                    index = ltr
                        ? (enabledTabs.length + index - 1) % enabledTabs.length
                        : (index + 1) % enabledTabs.length;
                    break;
                case 'ArrowRight':
                    index = ltr
                        ? (index + 1) % enabledTabs.length
                        : (enabledTabs.length + index - 1) % enabledTabs.length;
                    break;
                case 'Home':
                    index = 0;
                    break;
                case 'End':
                    index = enabledTabs.length - 1;
                    break;
                case 'Enter':
                case ' ':
                    this.setSelectedTab(enabledTabs[index]);
                    break;
                default:
                    return;
            }
            enabledTabs[index].focus({ preventScroll: true });
            if (this.activation === 'auto') {
                this.setSelectedTab(enabledTabs[index]);
                this.emitEvent('igcChange', { detail: this.activeTab });
            }
            else {
                enabledTabs[index].scrollIntoView({ block: 'nearest' });
            }
            event.preventDefault();
        };
    }
    get enabledTabs() {
        return this.tabs.filter((tab) => !tab.disabled);
    }
    get selected() {
        var _a, _b;
        return (_b = (_a = this.activeTab) === null || _a === void 0 ? void 0 : _a.panel) !== null && _b !== void 0 ? _b : '';
    }
    alignIndicator() {
        const styles = {
            visibility: this.activeTab ? 'visible' : 'hidden',
            transitionDuration: '0.3s',
        };
        if (this.activeTab) {
            Object.assign(styles, {
                width: `${this.activeTab.offsetWidth}px`,
                transform: `translate(${isLTR(this)
                    ? getOffset(this.activeTab, this.wrapper).left
                    : getOffset(this.activeTab, this.wrapper).right}px)`,
            });
        }
        Object.assign(this.selectedIndicator.style, styles);
    }
    async firstUpdated() {
        var _a;
        this.showScrollButtons =
            this.container.scrollWidth > this.container.clientWidth;
        await this.updateComplete;
        this.syncAttributes();
        this.setupObserver();
        this.setSelectedTab((_a = this.tabs.filter((tab) => tab.selected).at(-1)) !== null && _a !== void 0 ? _a : this.enabledTabs.at(0));
        this.updateSelectedTab();
    }
    disconnectedCallback() {
        var _a, _b;
        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
        (_b = this.mutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        super.disconnectedCallback();
    }
    updateButtonsOnResize() {
        this.showScrollButtons = false;
        this.performUpdate();
        this.showScrollButtons =
            this.container.scrollWidth > this.container.clientWidth;
        this.updateScrollButtons();
    }
    updateScrollButtons() {
        const { scrollLeft, offsetWidth } = this.container, { scrollWidth } = this.wrapper;
        this.disableEndScrollButton =
            scrollWidth <= Math.abs(scrollLeft) + offsetWidth;
        this.disableStartScrollButton = scrollLeft === 0;
    }
    setupObserver() {
        this.resizeObserver = new ResizeObserver(() => {
            this.updateButtonsOnResize();
            this.alignIndicator();
        });
        [this.container, this.wrapper, ...this.tabs].forEach((element) => this.resizeObserver.observe(element));
        this.mutationObserver = new MutationObserver(async (records, observer) => {
            var _a;
            observer.disconnect();
            const attributes = getAttributesForTags(records, 'igc-tab');
            const changed = getNodesForTags(records, this, 'igc-tab');
            if (attributes.length > 0) {
                this.activeTab = attributes.find((tab) => tab.selected);
            }
            if (changed) {
                changed.addedNodes.forEach((tab) => {
                    this.resizeObserver.observe(tab);
                    if (tab.selected) {
                        this.activeTab = tab;
                    }
                });
                changed.removedNodes.forEach((tab) => {
                    this.resizeObserver.unobserve(tab);
                    if (tab.selected || this.activeTab === tab) {
                        this.activeTab = undefined;
                    }
                });
                this.syncAttributes();
            }
            this.updateSelectedTab();
            (_a = this.activeTab) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ block: 'nearest' });
            this.alignIndicator();
            await this.updateComplete;
            observer.observe(this, observerConfig);
        });
        this.mutationObserver.observe(this, observerConfig);
    }
    updateSelectedTab() {
        this.tabs.forEach((tab) => (tab.selected = tab === this.activeTab));
        this.panels.forEach((panel) => {
            var _a;
            panel.hidden = panel.id !== ((_a = this.activeTab) === null || _a === void 0 ? void 0 : _a.panel);
        });
    }
    syncAttributes() {
        const prefix = this.id ? `${this.id}-` : '';
        this.tabs.forEach((tab, index) => {
            var _a, _b, _c;
            if (!tab.panel) {
                tab.panel =
                    (_b = (_a = this.panels.at(index)) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : `${prefix}tab-${IgcTabsComponent_1.increment()}`;
            }
            (_c = this.panels
                .find((panel) => panel.id === tab.panel)) === null || _c === void 0 ? void 0 : _c.setAttribute('aria-labelledby', tab.id);
        });
    }
    setSelectedTab(tab) {
        if (!tab || tab === this.activeTab) {
            return;
        }
        if (this.activeTab) {
            this.activeTab.selected = false;
        }
        this.activeTab = tab;
        this.activeTab.selected = true;
    }
    scrollByTabOffset(direction) {
        const { scrollLeft, offsetWidth } = this.container;
        const LTR = isLTR(this), next = direction === 'end';
        const pivot = Math.abs(next ? offsetWidth + scrollLeft : scrollLeft);
        let amount = this.tabs
            .map((tab) => ({
            start: LTR
                ? getOffset(tab, this.wrapper).left
                : Math.abs(getOffset(tab, this.wrapper).right),
            width: tab.offsetWidth,
        }))
            .filter((offset) => next ? offset.start + offset.width > pivot : offset.start < pivot)
            .at(next ? 0 : -1).width;
        amount *= next ? 1 : -1;
        this.container.scrollBy({ left: LTR ? amount : -amount });
    }
    handleClick(event) {
        const target = event.target;
        const tab = target.closest('igc-tab');
        if (!(tab && this.contains(tab)) || tab.disabled) {
            return;
        }
        tab.focus();
        this.setSelectedTab(tab);
        this.emitEvent('igcChange', { detail: this.activeTab });
    }
    handleScroll() {
        this.updateScrollButtons();
    }
    select(name) {
        this.setSelectedTab(this.tabs.find((el) => el.panel === name));
    }
    renderScrollButton(direction) {
        const start = direction === 'start';
        return this.showScrollButtons
            ? html `<igc-icon-button
          tabindex="-1"
          aria-hidden="true"
          size="large"
          variant="flat"
          collection="internal"
          part="${direction}-scroll-button"
          name="navigate_${start ? 'before' : 'next'}"
          .disabled=${start
                ? this.disableStartScrollButton
                : this.disableEndScrollButton}
          @click=${() => this.scrollByTabOffset(direction)}
        ></igc-icon-button>`
            : nothing;
    }
    render() {
        return html `
      <div part="headers">
        ${this.renderScrollButton('start')}
        <div part="headers-content" @scroll=${this.handleScroll}>
          <div part="headers-wrapper">
            <div
              part="headers-scroll"
              role="tablist"
              @click=${this.handleClick}
              @keydown=${this.handleKeyDown}
            >
              <slot></slot>
            </div>
            <div part="selected-indicator"></div>
          </div>
        </div>
        ${this.renderScrollButton('end')}
      </div>
      <div part="content">
        <slot name="panel"></slot>
      </div>
    `;
    }
};
IgcTabsComponent.tagName = 'igc-tabs';
IgcTabsComponent.styles = styles;
IgcTabsComponent.increment = createCounter();
__decorate([
    queryAssignedElements({ selector: 'igc-tab' })
], IgcTabsComponent.prototype, "tabs", void 0);
__decorate([
    queryAssignedElements({ slot: 'panel' })
], IgcTabsComponent.prototype, "panels", void 0);
__decorate([
    query('[part="headers-wrapper"]', true)
], IgcTabsComponent.prototype, "wrapper", void 0);
__decorate([
    query('[part="headers-content"]', true)
], IgcTabsComponent.prototype, "container", void 0);
__decorate([
    query('[part="selected-indicator"]', true)
], IgcTabsComponent.prototype, "selectedIndicator", void 0);
__decorate([
    state()
], IgcTabsComponent.prototype, "showScrollButtons", void 0);
__decorate([
    state()
], IgcTabsComponent.prototype, "disableStartScrollButton", void 0);
__decorate([
    state()
], IgcTabsComponent.prototype, "disableEndScrollButton", void 0);
__decorate([
    state()
], IgcTabsComponent.prototype, "activeTab", void 0);
__decorate([
    property({ reflect: true })
], IgcTabsComponent.prototype, "alignment", void 0);
__decorate([
    property()
], IgcTabsComponent.prototype, "activation", void 0);
__decorate([
    watch('alignment', { waitUntilFirstUpdate: true })
], IgcTabsComponent.prototype, "alignIndicator", null);
__decorate([
    eventOptions({ passive: true })
], IgcTabsComponent.prototype, "handleScroll", null);
IgcTabsComponent = IgcTabsComponent_1 = __decorate([
    themes({ bootstrap, fluent, indigo }),
    blazorAdditionalDependencies('IgcTabComponent, IgcTabPanelComponent')
], IgcTabsComponent);
export default IgcTabsComponent;
//# sourceMappingURL=tabs.js.map