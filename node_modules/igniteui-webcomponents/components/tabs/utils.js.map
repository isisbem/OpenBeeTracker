{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/components/tabs/utils.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,MAAM,cAAc,GAAyB;IAClD,UAAU,EAAE,IAAI;IAChB,eAAe,EAAE,CAAC,UAAU,CAAC;IAC7B,SAAS,EAAE,IAAI;IACf,OAAO,EAAE,IAAI;CACd,CAAC;AAEF,SAAS,aAAa,CAAC,IAAU,EAAE,GAAG,IAAc;IAClD,OAAO,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;AAClE,CAAC;AAKD,MAAM,UAAU,oBAAoB,CAClC,OAAyB,EACzB,GAAG,IAAc;IAEjB,OAAO,OAAO;SACX,MAAM,CACL,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE,CACnB,IAAI,KAAK,YAAY,IAAI,aAAa,CAAC,MAAM,EAAE,GAAG,IAAI,CAAC,CAC1D;SACA,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC,MAAW,CAAC,CAAC;AACtC,CAAC;AAOD,MAAM,UAAU,eAAe,CAC7B,OAAyB,EACzB,IAAc,EACd,GAAG,IAAc;IAEjB,MAAM,SAAS,GAGX,EAAE,UAAU,EAAE,EAAE,EAAE,YAAY,EAAE,EAAE,EAAE,CAAC;IAEzC,OAAO;SACJ,MAAM,CACL,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE,CACnB,IAAI,KAAK,WAAW,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAClE;SACA,MAAM,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE;QACrB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CACtC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC;aACxB,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,aAAa,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,CAAC;aAC9C,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAS,CAAC,CAC5B,CAAC;QACF,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,CAC1C,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC;aAC1B,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,aAAa,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,CAAC;aAC9C,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAS,CAAC,CAC5B,CAAC;QACF,OAAO,IAAI,CAAC;IACd,CAAC,EAAE,SAAS,CAAC,CAAC;IAEhB,OAAO,SAAS,CAAC,UAAU,CAAC,MAAM,IAAI,SAAS,CAAC,YAAY,CAAC,MAAM;QACjE,CAAC,CAAC,SAAS;QACX,CAAC,CAAC,IAAI,CAAC;AACX,CAAC","sourcesContent":["export const observerConfig: MutationObserverInit = {\n  attributes: true,\n  attributeFilter: ['selected'],\n  childList: true,\n  subtree: true,\n};\n\nfunction isMatchingTag(node: Node, ...tags: string[]) {\n  return tags ? tags.includes(node.nodeName.toLowerCase()) : true;\n}\n\n/**\n * Returns all targets with attribute mutations matching `tags`\n */\nexport function getAttributesForTags<T extends Element>(\n  records: MutationRecord[],\n  ...tags: string[]\n) {\n  return records\n    .filter(\n      ({ type, target }) =>\n        type === 'attributes' && isMatchingTag(target, ...tags)\n    )\n    .map(({ target }) => target as T);\n}\n\n/**\n * Returns all targets with childList mutations matching tags.\n * If `root` is specified, returns only targets that are direct children\n * of `root`.\n */\nexport function getNodesForTags<T extends Element>(\n  records: MutationRecord[],\n  root?: Element,\n  ...tags: string[]\n) {\n  const collected: {\n    addedNodes: T[];\n    removedNodes: T[];\n  } = { addedNodes: [], removedNodes: [] };\n\n  records\n    .filter(\n      ({ type, target }) =>\n        type === 'childList' && (root ? target.isSameNode(root) : true)\n    )\n    .reduce((prev, curr) => {\n      prev.addedNodes = prev.addedNodes.concat(\n        Array.from(curr.addedNodes)\n          .filter((node) => isMatchingTag(node, ...tags))\n          .map((node) => node as T)\n      );\n      prev.removedNodes = prev.removedNodes.concat(\n        Array.from(curr.removedNodes)\n          .filter((node) => isMatchingTag(node, ...tags))\n          .map((node) => node as T)\n      );\n      return prev;\n    }, collected);\n\n  return collected.addedNodes.length || collected.removedNodes.length\n    ? collected\n    : null;\n}\n"]}